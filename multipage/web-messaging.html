<!DOCTYPE html><html class=split lang=en-US-x-hixie><script src=/html/link-fixup.js defer=""></script><meta charset=utf-8><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name=viewport><title>HTML Standard</title><meta content=#3c790a name=theme-color><link rel=stylesheet href=https://resources.whatwg.org/spec.css crossorigin=""><link rel=stylesheet href=https://resources.whatwg.org/standard.css crossorigin=""><link rel=stylesheet href=https://resources.whatwg.org/standard-shared-with-dev.css crossorigin=""><link rel=icon href=https://resources.whatwg.org/logo.svg crossorigin=""><link rel=stylesheet href=/html/styles.css crossorigin=""><script>
   function toggleStatus(div) {
     div.parentNode.classList.toggle('wrapped');
   }
   function setLinkFragment(link) {
     link.hash = location.hash;
   }
  </script><link rel=stylesheet href=/html/resources/zh-cn.css><body>
  
  <script async="" crossorigin="" src=/html/resources/html-dfn.js></script>
  <script data-file-issue-url=https://github.com/whatwg/html/issues/new async="" crossorigin="" src=https://resources.whatwg.org/file-issue.js></script>
  
  <header id=head class="head with-buttons">
   <a href=https://whatwg.org/ class=logo><img width=100 alt=WHATWG crossorigin="" src=https://resources.whatwg.org/logo.svg height=100></a>
   <hgroup><h1 class=allcaps>HTML</h1><h2 id=living-standard class="no-num no-toc">Living Standard — Last Updated <span class=pubdate>20 June 2021</span></h2><div data-en-date="Sat Aug 11 2018 08:00:56 GMT+0000 (UTC)" class=translate-info data-zh-date="" data-en-file=https://github.com/whatwg-cn/html/blob/master/src/living-standard-mdash-last-updated-date-01-jan-1901.en.html data-zh-file="https://github.com/whatwg-cn/html/new/master/src/living-standard-mdash-last-updated-date-01-jan-1901.zh.html?filename=living-standard-mdash-last-updated-date-01-jan-1901.zh.html&amp;value=%E4%BB%8E%20https%3A%2F%2Fgithub.com%2Fwhatwg-cn%2Fhtml%2Fblob%2Fmaster%2Fsrc%2Fliving-standard-mdash-last-updated-date-01-jan-1901.en.html%20%E6%8B%B7%E8%B4%9D%E8%8B%B1%E6%96%87%E6%BA%90%E7%A0%81%E8%87%B3%E6%AD%A4%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%BF%BB%E8%AF%91"></div><div data-en-date="Sat Aug 11 2018 08:00:56 GMT+0000 (UTC)" class=translate-info data-zh-date="" data-en-file=https://github.com/whatwg-cn/html/blob/master/src/commit-snapshot-mdash-last-updated-date-01-jan-1901.en.html data-zh-file="https://github.com/whatwg-cn/html/new/master/src/commit-snapshot-mdash-last-updated-date-01-jan-1901.zh.html?filename=commit-snapshot-mdash-last-updated-date-01-jan-1901.zh.html&amp;value=%E4%BB%8E%20https%3A%2F%2Fgithub.com%2Fwhatwg-cn%2Fhtml%2Fblob%2Fmaster%2Fsrc%2Fcommit-snapshot-mdash-last-updated-date-01-jan-1901.en.html%20%E6%8B%B7%E8%B4%9D%E8%8B%B1%E6%96%87%E6%BA%90%E7%A0%81%E8%87%B3%E6%AD%A4%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%BF%BB%E8%AF%91"></div><div data-en-date="Sat Aug 11 2018 08:00:56 GMT+0000 (UTC)" class=translate-info data-zh-date="" data-en-file=https://github.com/whatwg-cn/html/blob/master/src/review-draft-mdash-published-date-01-jan-1901.en.html data-zh-file="https://github.com/whatwg-cn/html/new/master/src/review-draft-mdash-published-date-01-jan-1901.zh.html?filename=review-draft-mdash-published-date-01-jan-1901.zh.html&amp;value=%E4%BB%8E%20https%3A%2F%2Fgithub.com%2Fwhatwg-cn%2Fhtml%2Fblob%2Fmaster%2Fsrc%2Freview-draft-mdash-published-date-01-jan-1901.en.html%20%E6%8B%B7%E8%B4%9D%E8%8B%B1%E6%96%87%E6%BA%90%E7%A0%81%E8%87%B3%E6%AD%A4%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%BF%BB%E8%AF%91"></div></hgroup>
   
   
   <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-91053840-1', 'auto');
      ga('send', 'pageview');
   </script>
  </header>

  

  


  
<div data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-file=https://github.com/whatwg-cn/html/blob/master/src/table-of-contents.en.html data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/table-of-contents.zh.html></div>
  


  
<div data-en-date="Sat Aug 11 2018 08:00:56 GMT+0000 (UTC)" class=translate-info data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-file=https://github.com/whatwg-cn/html/blob/master/src/full-table-of-contents.en.html data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/full-table-of-contents.zh.html></div>
  

  

  


  <nav><a href=web-sockets.html>← 9.3 Web sockets</a> — <a href=./>Table of Contents</a> — <a href=workers.html>10 Web 工作线程 →</a></nav><ol class=toc><li id=toc-comms><ol><li><a href=web-messaging.html#web-messaging><span class=secno>9.4</span> 跨文档通信</a><ol><li><a href=web-messaging.html#概述-5><span class=secno>9.4.1</span> 概述</a><li><a href=web-messaging.html#security-postmsg><span class=secno>9.4.2</span> 安全</a><ol><li><a href=web-messaging.html#作者><span class=secno>9.4.2.1</span> 作者</a><li><a href=web-messaging.html#用户代理><span class=secno>9.4.2.2</span> 用户代理</a></ol><li><a href=web-messaging.html#发布消息><span class=secno>9.4.3</span> 发布消息</a></ol><li><a href=web-messaging.html#通道><span class=secno>9.5</span> 通道</a><ol><li><a href=web-messaging.html#概述-6><span class=secno>9.5.1</span> 概述</a><ol><li><a href=web-messaging.html#示例><span class=secno>9.5.1.1</span> 示例</a><li><a href=web-messaging.html#端口作为-web-上对象能力模型的基础><span class=secno>9.5.1.2</span> 端口作为 Web 上对象能力模型的基础</a><li><a href=web-messaging.html#端口作为抽象服务实现的基础><span class=secno>9.5.1.3</span> 端口作为抽象服务实现的基础</a></ol><li><a href=web-messaging.html#消息通道><span class=secno>9.5.2</span> 消息通道</a><li><a href=web-messaging.html#消息端口><span class=secno>9.5.3</span> 消息端口</a><li><a href=web-messaging.html#广播给多个端口><span class=secno>9.5.4</span> 广播给多个端口</a><li><a href=web-messaging.html#ports-and-garbage-collection><span class=secno>9.5.5</span> 端口与垃圾回收</a></ol><li><a href=web-messaging.html#向其他浏览上下文广播><span class=secno>9.6</span> 向其他浏览上下文广播</a></ol></ol><h3 id=web-messaging><span class=secno>9.4</span> <dfn id=crossDocumentMessages>跨文档通信</dfn><a href=#web-messaging class=self-link></a></h3><div class="mdn-anno wrapped"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage title="The window.postMessage() method safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.">Window/postMessage</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>8+</span></span><span class="safari yes"><span>Safari</span><span>4+</span></span><span class="chrome yes"><span>Chrome</span><span>1+</span></span><hr><span class="opera yes"><span>Opera</span><span>9.5+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>8+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>3.2+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>≤37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>10.1+</span></span></div></div></div>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/index.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/index.en.html></div>

  <p>Web 浏览器由于安全和隐私等原因禁止不同域的文档见互相影响，也就是说不允许跨站脚本。</p>

  <p>虽然这是一个非常重要的安全特性，但它也阻止了不同域的页面之间进行非恶意的通信。
  本章引入了一个消息系统来允许不同源的文档间通信，这一设计不会引起跨站脚本攻击。</p>

  <p id=fingerprint-postMessage class=note>
  
  <code id=web-messaging:dom-window-postmessage><a href=#dom-window-postmessage>postMessage()</a></code> API 可以用作 <a href=https://infra.spec.whatwg.org/#tracking-vector id=web-messaging:tracking-vector data-x-internal=tracking-vector>跟踪向量</a>。</p>


  <h4 id=概述-5><span class=secno>9.4.1</span> 概述<a href=#概述-5 class=self-link></a></h4>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/introduction.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/introduction.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <div class=example>

   <p>例如，如果文档 A 包含一个 <code id=概述-5:the-iframe-element><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 元素，其中包含文档 B，
   A 中的脚本调用了 B 的 <code id=概述-5:window><a href=window-object.html#window>Window</a></code> 对象上的
   <code id=概述-5:dom-window-postmessage><a href=#dom-window-postmessage>postMessage()</a></code>，
   然后这个对象上会产生一个消息事件，标记为源自文档 A 的 <code id=概述-5:window-2><a href=window-object.html#window>Window</a></code>。
   文档 A 中的脚本可能像这样：</p>

   <pre>var o = document.getElementsByTagName('iframe')[0];
o.contentWindow.postMessage('Hello world', 'https://b.example.org/');</pre>

   <p>脚本通过 <code>addEventListener()</code>（或类似机制）
   为传入的事件注册事件处理器。例如文档 B 中的脚本可能像这样：</p>

   <pre>window.addEventListener('message', receiver, false);
function receiver(e) {
  if (e.origin == 'https://example.com') {
    if (e.data == 'Hello world') {
      e.source.postMessage('Hello', e.origin);
    } else {
      alert(e.data);
    }
  }
}</pre>

   <p>该脚本先检查域是否符合预期，
   然后再检查消息，把它显示给用户或者把它发送回首先发送消息的文档。</p>

  </div>




  <h4 id=security-postmsg><span class=secno>9.4.2</span> 安全<a href=#security-postmsg class=self-link></a></h4>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/security/index.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/security/index.en.html></div>

  


  <h5 id=作者><span class=secno>9.4.2.1</span> 作者<a href=#作者 class=self-link></a></h5>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/security/authors.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/security/authors.en.html></div>

  

  <p id=security-4 class=warning>使用此 API 需要格外小心，
  以防止恶意实体为达到自己的目的在网站上滥用。</p>

  <p>作者应该检查 <code id=作者:dom-messageevent-origin><a href=comms.html#dom-messageevent-origin>origin</a></code>
  属性以确保只从他们期望的域接收消息。否则，作者的消息处理代码中的错误可能会被恶意网站利用。</p>

  <p>此外，即使在检查
  <code id=作者:dom-messageevent-origin-2><a href=comms.html#dom-messageevent-origin>origin</a></code>
  属性后，作者也应该检查相关数据的格式。否则，如果事件的源被跨站脚本攻击，对通过
  <code id=作者:dom-window-postmessage><a href=#dom-window-postmessage>postMessage()</a></code>
  方法发送的消息的未经检查的处理可能会把攻击传播到接收者。</p>

  <p>对于任何包含机密信息的消息中，作者不应在
  <var>targetOrigin</var> 参数中使用通配符关键字（*），否则无法保证消息仅传递给它希望的接收方。</p>

  <hr>

  <p>鼓励接受任何来源消息的作者考虑 DoS 攻击的风险。攻击者可能会发送大量的消息；
  如果接收页面执行了耗时的计算或为每个此类消息产生网络流量，
  则攻击者的消息可能会被成倍放大，从而导致 DoS 攻击。
  鼓励作者采用速率限制（每分钟只接受一定数量的消息）以使这种攻击不可行。</p>


  


  <h5 id=用户代理><span class=secno>9.4.2.2</span> 用户代理<a href=#用户代理 class=self-link></a></h5>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/security/user-agents.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/security/user-agents.en.html></div>

  <p>本 API 的完整性基于一个 <a href=origin.html#concept-origin id=用户代理:concept-origin>域</a>
  的脚本无法向其他（<a href=origin.html#same-origin id=用户代理:same-origin>不同的</a>）域
  （使用 <code>dispatchEvent()</code> 或其他方法）发送任意事件。</p>

  <p class=note>强烈建议实现方在实现这项功能时要格外小心。
  它允许作者将信息从一个域传送到另一个域，通常出于安全原因这是不允许的。
  它还要求 UA 小心地允许访问某些属性，但禁止其他的。</p>

  <hr>

  <p>也鼓励用户代理考虑对不同 <a href=origin.html#concept-origin id=用户代理:concept-origin-2>域</a>
  之间的消息进行速率限制，来保护简单的网站不受 DoS 攻击。</p>

  





  <h4 id=发布消息><span class=secno>9.4.3</span> 发布消息<a href=#发布消息 class=self-link></a></h4>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/cross-document-messaging/posting-messages.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/cross-document-messaging/posting-messages.en.html></div>

  <dl class=domintro><dt><var>window</var> . <code id=dom-window-postmessage-options-dev><a href=#dom-window-postmessage-options>postMessage</a></code>(<var>message</var> [, <var>options</var> ] )<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage title="The window.postMessage() method safely enables cross-origin communication between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.">Window/postMessage</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>8+</span></span><span class="safari yes"><span>Safari</span><span>4+</span></span><span class="chrome yes"><span>Chrome</span><span>1+</span></span><hr><span class="opera yes"><span>Opera</span><span>9.5+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>8+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>3.2+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>10.1+</span></span></div></div></div><dd>

    <p>像指定的 window 发送消息。消息可以是结构化的对象，
    例如嵌套对象和数组，可以包含 JavaScript 值（字符串、数字、<code id=发布消息:date><a data-x-internal=date href=https://tc39.es/ecma262/#sec-date-objects>Date</a></code>、对象等等），
    也可以包含数据对象比如 <code id=发布消息:file><a data-x-internal=file href=https://w3c.github.io/FileAPI/#dfn-file>File</a></code> <code id=发布消息:blob><a data-x-internal=blob href=https://w3c.github.io/FileAPI/#dfn-Blob>Blob</a></code>，<code id=发布消息:filelist><a data-x-internal=filelist href=https://w3c.github.io/FileAPI/#filelist-section>FileList</a></code>，
    以及 <code id=发布消息:idl-arraybuffer><a data-x-internal=idl-arraybuffer href=https://heycam.github.io/webidl/#idl-ArrayBuffer>ArrayBuffer</a></code> 对象。</p>

    <p><var>options</var> 的 <code id=发布消息:dom-postmessageoptions-transfer><a href=#dom-postmessageoptions-transfer>transfer</a></code> 成员中的对象会被转移（不是克隆），
    意味着它们在发送侧不再可用。</p>

    <p>可以用 <var>options</var> 的 <code id=发布消息:dom-windowpostmessageoptions-targetorigin><a href=window-object.html#dom-windowpostmessageoptions-targetorigin>targetOrigin</a></code> 成员来指定目标源。
    如果没有指定，默认为 "<code>/</code>"。这个默认值限制了消息只能发送到同源目标。</p>

    <p>为避免信息泄露，如果目标窗口的源不匹配给定的源消息会被丢弃。如果要无视目标源直接发送消息，需要设置目标源为 "<code>*</code>"。</p>

    <p>如果 <var>transfer</var> 数组包含重复的对象，或者 <var>message</var> 不可克隆时，
    抛出一个 <a id=发布消息:datacloneerror href=https://heycam.github.io/webidl/#datacloneerror data-x-internal=datacloneerror>"<code>DataCloneError</code>"</a> <code id=发布消息:domexception><a data-x-internal=domexception href=https://heycam.github.io/webidl/#dfn-DOMException>DOMException</a></code>。</p>

   <dt><var>window</var> . <code id=发布消息:dom-window-postmessage><a href=#dom-window-postmessage>postMessage</a></code>(<var>message</var>, <var>targetOrigin</var> [, <var>transfer</var> ] )<dd><p>这是 <code id=发布消息:dom-window-postmessage-options><a href=#dom-window-postmessage-options>postMessage()</a></code> 的另一个版本，以目标源作为参数。调用
   <code>window.postMessage(message, target, transfer)</code> 等价于
   <code>window.postMessage(message, {targetOrigin, transfer})</code>。</dl>

  <p class=note>给刚导航到新 <code id=发布消息:document><a href=dom.html#document>Document</a></code> 的 <a id=发布消息:browsing-context href=browsers.html#browsing-context>browsing context</a> 上的
  <code id=发布消息:window><a href=window-object.html#window>Window</a></code> 发布消息时，消息可能无法到达接收者：
  目标 <a href=browsers.html#browsing-context id=发布消息:browsing-context-2>浏览上下文</a> 中的脚本必须有时间设置消息监听器。
  因此，如果要发送消息给一个刚创建的子 <code id=发布消息:the-iframe-element><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 的 <code id=发布消息:window-2><a href=window-object.html#window>Window</a></code>，
  建议作者在子 <code id=发布消息:document-2><a href=dom.html#document>Document</a></code> 中发送消息给父级来声明它已经准备好接收消息了，
  父级则等待该消息到来后再开发发送消息。</p>

  

  <p>给定 <var>targetWindow</var>, <var>message</var> 和 <var>options</var> 的 <dfn id=window-post-message-steps>窗口发送消息步骤</dfn> 如下：</p>

  <ol><li><p>令 <var>targetRealm</var> 为 <var>targetWindow</var> 的 <a href=webappapis.html#concept-global-object-realm id=发布消息:concept-global-object-realm>Realm</a>。<li><p>令 <var>incumbentSettings</var> 为
   <a href=webappapis.html#incumbent-settings-object id=发布消息:incumbent-settings-object>当前设置对象</a>。<li><p>令 <var>targetOrigin</var> 为 <var>options</var>["<code id=发布消息:dom-windowpostmessageoptions-targetorigin-2><a href=window-object.html#dom-windowpostmessageoptions-targetorigin>targetOrigin</a></code>"]。<li><p>如果 <var>targetOrigin</var> 是一个 U+002F SOLIDUS 字符 (/)，则将
   <var>targetOrigin</var> 设置为 <var>incumbentSettings</var> 的 <a href=webappapis.html#concept-settings-object-origin id=发布消息:concept-settings-object-origin>origin</a>。</p>

   <li>
    <p>否则，如果 <var>targetOrigin</var> 不是一个 U+002A ASTERISK 字符 (*)，则：</p>

    <ol><li><p>令 <var>parsedURL</var> 为在 <var>targetOrigin</var> 上执行
       <a href=https://url.spec.whatwg.org/#concept-url-parser id=发布消息:url-parser data-x-internal=url-parser>URL 解析</a> 的结果。<li><p>如果 <var>parsedURL</var> 是失败，则抛出 <a id=发布消息:syntaxerror href=https://heycam.github.io/webidl/#syntaxerror data-x-internal=syntaxerror>"<code>SyntaxError</code>"</a>
     <code id=发布消息:domexception-2><a data-x-internal=domexception href=https://heycam.github.io/webidl/#dfn-DOMException>DOMException</a></code>。<li><p>设置 <var>targetOrigin</var> 为 <var>parsedURL</var> 的 <a href=https://url.spec.whatwg.org/#concept-url-origin id=发布消息:concept-url-origin data-x-internal=concept-url-origin>origin</a>。</ol>
   <li><p>令 <var>transfer</var> 为 <var>options</var>["<code id=发布消息:dom-postmessageoptions-transfer-2><a href=#dom-postmessageoptions-transfer>transfer</a></code>"]。<li><p>令 <var>serializeWithTransferResult</var> 为
   <a id=发布消息:structuredserializewithtransfer href=infrastructure.html#structuredserializewithtransfer>StructuredSerializeWithTransfer</a>(<var>message</var>, <var>transfer</var>)。
   重新抛出任何异常。<li>
    <p>在 <dfn id=posted-message-task-source>已发送消息任务源</dfn> 上给定 <var>targetWindow</var>
     <a href=webappapis.html#queue-a-global-task id=发布消息:queue-a-global-task>入队一个全局任务</a> 来执行以下步骤：</p>

    <ol><li><p>如果 <var>targetOrigin</var> 参数不是单个 U+002A ASTERISK 字符 (*) 且
     <var>targetWindow</var> 的 <a href=window-object.html#concept-document-window id=发布消息:concept-document-window>关联
     <code>Document</code></a> 的 <a href=origin.html#concept-origin id=发布消息:concept-origin>源</a> 不
     与 <var>targetOrigin</var> <a href=origin.html#same-origin id=发布消息:same-origin>同源</a>，则返回。<li><p>令 <var>origin</var> 为 <var>incumbentSettings</var>
     的 <a href=webappapis.html#concept-settings-object-origin id=发布消息:concept-settings-object-origin-2>origin</a>
     的 <a href=origin.html#ascii-serialisation-of-an-origin id=发布消息:ascii-serialisation-of-an-origin>序列化</a>。<li><p>令 <var>source</var> 为 <code id=发布消息:windowproxy><a href=window-object.html#windowproxy>WindowProxy</a></code> 对象对应的
     <var>incumbentSettings</var> 的 <a href=webappapis.html#concept-settings-object-global id=发布消息:concept-settings-object-global>全局对象</a>
     （一个 <code id=发布消息:window-3><a href=window-object.html#window>Window</a></code> 对象）。<li>
      <p>令 <var>deserializeRecord</var> 为
      <a id=发布消息:structureddeserializewithtransfer href=infrastructure.html#structureddeserializewithtransfer>StructuredDeserializeWithTransfer</a>(<var>serializeWithTransferResult</var>,
      <var>targetRealm</var>)。</p>

      <p>如果这抛出了异常，捕获它并使用 <code id=发布消息:messageevent><a href=comms.html#messageevent>MessageEvent</a></code>
      在 <var>targetWindow</var> 上
      <a href=https://dom.spec.whatwg.org/#concept-event-fire id=发布消息:concept-event-fire data-x-internal=concept-event-fire>产生</a> 一个名为
      <code id=发布消息:event-messageerror><a href=indices.html#event-messageerror>messageerror</a></code> 的事件，
      并把 <code id=发布消息:dom-messageevent-origin><a href=comms.html#dom-messageevent-origin>origin</a></code> 属性初始化为 <var>origin</var>，
      <code id=发布消息:dom-messageevent-source><a href=comms.html#dom-messageevent-source>source</a></code> 属性初始化为 <var>source</var>，
      然后返回。</p>
     <li><p>令 <var>messageClone</var> 为 <var>deserializeRecord</var>.[[Deserialized]]。<li><p>令 <var>newPorts</var> 为一个新的 <a id=发布消息:frozen-array href=https://heycam.github.io/webidl/#dfn-frozen-array-type data-x-internal=frozen-array>frozen array</a>，包含
     <var>deserializeRecord</var>.[[TransferredValues]] 中所有的
     <code id=发布消息:messageport><a href=#messageport>MessagePort</a></code> 对象（如果有的话），
     并保持它们的相对顺序。<li><p><a href=https://dom.spec.whatwg.org/#concept-event-fire id=发布消息:concept-event-fire-2 data-x-internal=concept-event-fire>
     使用 <code>MessageEvent</code> 在 <var>targetWindow</var> 上
     产生</a> 一个名为 <code id=发布消息:event-message><a href=indices.html#event-message>message</a></code> 的事件，
     其 <code id=发布消息:dom-messageevent-origin-2><a href=comms.html#dom-messageevent-origin>origin</a></code> 属性初始化为 <var>origin</var>，
     <code id=发布消息:dom-messageevent-source-2><a href=comms.html#dom-messageevent-source>source</a></code> 属性初始化为 <var>source</var>，
     <code id=发布消息:dom-messageevent-data><a href=comms.html#dom-messageevent-data>data</a></code> 属性初始化为 <var>messageClone</var>，
     <code id=发布消息:dom-messageevent-ports><a href=comms.html#dom-messageevent-ports>ports</a></code> 属性初始化为 <var>newPorts</var>。</ol>
   </ol>

  <p>在 <code id=发布消息:window-4><a href=window-object.html#window>Window</a></code> 上调用 <dfn id=dom-window-postmessage-options><code>postMessage(<var>message</var>,
  <var>options</var>)</code></dfn> 方法时，必须执行以下步骤：</p>
  <ol><li><p>令 <var>targetWindow</var> 为这个 <code id=发布消息:window-5><a href=window-object.html#window>Window</a></code> 对象。<li><p>给定 <var>targetWindow</var>，<var>message</var> 和 <var>options</var>，
   执行 <a href=#window-post-message-steps id=发布消息:window-post-message-steps>窗口发送消息步骤</a>。</ol>

  <p>在 <code id=发布消息:window-6><a href=window-object.html#window>Window</a></code> 上调用 <dfn id=dom-window-postmessage><code>postMessage(<var>message</var>,
  <var>targetOrigin</var>, <var>transfer</var>)</code></dfn> 方法时，必须执行以下步骤：</p>

  <ol><li><p>令 <var>targetWindow</var> 为这个 <code id=发布消息:window-7><a href=window-object.html#window>Window</a></code> 对象。<li><p>令 <var>options</var> 为 «[ "<code id=发布消息:dom-windowpostmessageoptions-targetorigin-3><a href=window-object.html#dom-windowpostmessageoptions-targetorigin>targetOrigin</a></code>" →
   <var>targetOrigin</var>, "<code id=发布消息:dom-postmessageoptions-transfer-3><a href=#dom-postmessageoptions-transfer>transfer</a></code>" →
   <var>transfer</var> ]»。<li><p>给定 <var>targetWindow</var>，<var>message</var> 和 <var>options</var>，
   执行 <a href=#window-post-message-steps id=发布消息:window-post-message-steps-2>窗口发送消息步骤</a>。</ol>

  





  <h3 id=通道><span class=secno>9.5</span> <dfn>通道</dfn><a href=#通道 class=self-link></a></h3>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/index.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/index.en.html></div>


  <h4 id=概述-6><span class=secno>9.5.1</span> 概述<a href=#概述-6 class=self-link></a></h4>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/introduction/index.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/introduction/index.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <p>为了使独立的代码片段之间可以相互通信（例如运行在不同
  <a href=browsers.html#browsing-context id=概述-6:browsing-context>浏览上下文</a> 的代码直接通信），
  作者可以使用 <a href=#通道 id=概述-6:通道>Channel 通信</a>。</p>

  <p>该机制下的通信 Channel 实现为双向管道，两端各一个端口。
  从一个端口发送的消息被传递到另一个端口，反之亦然。
  消息被作为 DOM 事件传递，不会中断或阻塞正在执行的
  <a href=webappapis.html#concept-task id=概述-6:concept-task>任务</a>。</p>

  <p>创建连接（两个关联的端口）使用 <code>MessageChannel()</code>
  构造函数：</p>

  <pre>var channel = new MessageChannel();</pre>

  <p>其中一个端口作为本地端口保存，另一个发送到了远程代码，例如
  使用 <code id=概述-6:dom-window-postmessage><a href=#dom-window-postmessage>postMessage()</a></code>:</p>

  <pre>otherWindow.postMessage('hello', 'https://example.com', [channel.port2]);</pre>

  <p>发送消息使用端口上的 <code id=概述-6:dom-messageport-postmessage><a href=#dom-messageport-postmessage>postMessage()</a></code> 方法：</p>

  <pre>channel.port1.postMessage('hello');</pre>

  <p>接收消息需要监听 <code id=概述-6:event-message><a href=indices.html#event-message>message</a></code> 事件：</p>

  <pre>channel.port1.onmessage = handleMessage;
function handleMessage(event) {
  // message is in event.data
  // ...
}</pre>

  <p>发送到端口的数据可以是结构化的；例如向 <code id=概述-6:messageport><a href=#messageport>MessagePort</a></code> 传递字符串数组：</p>

  <pre>port1.postMessage(['hello', 'world']);</pre>



  <h5 id=示例><span class=secno>9.5.1.1</span> 示例<a href=#示例 class=self-link></a></h5>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/introduction/examples.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/introduction/examples.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <div class=example>

   <p>在这个例子中，两个 JavaScript 库通过 <code id=示例:messageport><a href=#messageport>MessagePort</a></code> 相互连接。
   这允许它们托管在不同的框架或 <code id=示例:worker><a href=workers.html#worker>Worker</a></code> 对象中而不需要改变 API。</p>

   <pre>&lt;script src="contacts.js">&lt;/script> &lt;!-- exposes a contacts object -->
&lt;script src="compose-mail.js">&lt;/script> &lt;!-- exposes a composer object -->
&lt;script>
 var channel = new MessageChannel();
 composer.addContactsProvider(channel.port1);
 contacts.registerConsumer(channel.port2);
&lt;/script></pre>

   <p>Here's what the "addContactsProvider()" function's implementation could look like:</p>

   <pre>function addContactsProvider(port) {
  port.onmessage = function (event) {
    switch (event.data.messageType) {
      'search-result': handleSearchResult(event.data.results); break;
      'search-done': handleSearchDone(); break;
      'search-error': handleSearchError(event.data.message); break;
      // ...
    }
  };
};</pre>

   <p>或者也可以这样实现：</p>

   <pre>function addContactsProvider(port) {
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-result')
      handleSearchResult(event.data.results);
  });
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-done')
      handleSearchDone();
  });
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-error')
      handleSearchError(event.data.message);
  });
  // ...
  port.start();
};</pre>

   <p>关键的区别在于，当使用 <code id=示例:dom-eventtarget-addeventlistener><a data-x-internal=dom-eventtarget-addeventlistener href=https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener>addEventListener()</a></code> 时，必须调用 <code id=示例:dom-messageport-start><a href=#dom-messageport-start>start()</a></code> 方法。当使用 <code id=示例:handler-messageport-onmessage><a href=#handler-messageport-onmessage>onmessage</a></code> 时，已经默认调用了 <code id=示例:dom-messageport-start-2><a href=#dom-messageport-start>start()</a></code>。</p>

   <p>无论显式或隐式地（通过设置 <code id=示例:handler-messageport-onmessage-2><a href=#handler-messageport-onmessage>onmessage</a></code>）
   调用 <code id=示例:dom-messageport-start-3><a href=#dom-messageport-start>start()</a></code> 方法，都会启动消息流：
   发送到消息端口的消息初始是暂停的，这样就不会在脚本还没能建立监听器之前被丢掉。</p>

  </div>



  <h5 id=端口作为-web-上对象能力模型的基础><span class=secno>9.5.1.2</span> 端口作为 Web 上对象能力模型的基础<a href=#端口作为-web-上对象能力模型的基础 class=self-link></a></h5>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/introduction/ports-as-the-basis-of-an-object-capability-model-on-the-web.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/introduction/ports-as-the-basis-of-an-object-capability-model-on-the-web.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <p>可以把端口当做为系统中其他角色提供有限能力的一种方式（在对象能力模型的意义上），
  这可能是一个弱能力的系统，用端口只是为了在源内通信的方便，
  也可能是一个强能力的系统，由一个源 <var>provider</var> 提供，作为唯一的机制给另一个源
  <var>consumer</var> 来从 <var>provider</var> 获取信息或造成改变。</p>

  <p>例如，考虑一个社交网站嵌入了一个 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code>
  它是用户的邮件联系人提供者（一个联系人网站，来自第二个源），
  以及第二个 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-2><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code>（一个游戏网站，来自第三个源）
  外面的社交网站和第二个 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-3><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中的游戏无法访问第一个 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-4><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中的任何东西；它们只能：</p>

  <ul class=brief><li>把 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-5><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> <a href=browsing-the-web.html#navigate id=端口作为-web-上对象能力模型的基础:navigate>导航</a> 到新的 <a id=端口作为-web-上对象能力模型的基础:url href=https://url.spec.whatwg.org/#concept-url data-x-internal=url>URL</a>，
   比如同样的 <a id=端口作为-web-上对象能力模型的基础:url-2 href=https://url.spec.whatwg.org/#concept-url data-x-internal=url>URL</a> 但有不同的 <a href=https://url.spec.whatwg.org/#concept-url-fragment id=端口作为-web-上对象能力模型的基础:concept-url-fragment data-x-internal=concept-url-fragment>fragment</a>，
   使 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-6><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中的 <code id=端口作为-web-上对象能力模型的基础:window><a href=window-object.html#window>Window</a></code> 收到一个
   <code id=端口作为-web-上对象能力模型的基础:event-hashchange><a href=indices.html#event-hashchange>hashchange</a></code> 事件。<li>改变 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-7><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 的大小，使 <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-8><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中的 <code id=端口作为-web-上对象能力模型的基础:window-2><a href=window-object.html#window>Window</a></code>
   收到一个 <code id=端口作为-web-上对象能力模型的基础:event-resize><a data-x-internal=event-resize href=https://drafts.csswg.org/cssom-view/#eventdef-window-resize>resize</a></code> 事件。<li>使用 <code id=端口作为-web-上对象能力模型的基础:dom-window-postmessage><a href=#dom-window-postmessage>window.postMessage()</a></code> API 发送一个
   <code id=端口作为-web-上对象能力模型的基础:event-message><a href=indices.html#event-message>message</a></code> 事件给
   <code id=端口作为-web-上对象能力模型的基础:the-iframe-element-9><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中的 <code id=端口作为-web-上对象能力模型的基础:window-3><a href=window-object.html#window>Window</a></code>。</ul>

  <p>联系人提供者使用这些方法（尤其是第三个）来给其他域提供操作用户地址簿的 API。
  例如，响应 "<code>add-contact Guillaume Tell
  &lt;tell@pomme.example.net></code>" 时，在用户的地址簿中新增指定的人和 e-mail。</p>

  <p>为了避免 Web 上任何站点都可以操作用户的地址簿，联系人提供者可能只允许确定的信任站点调用，
  比如这个社交网站。</p>

  <p>现在假设这个游戏希望添加联系人到用户的地址簿，而且这个社交网站也愿意允许它这样做，
  实质上是“共享”联系人提供者对社交网站的信任。实现这一共享有很多方式，
  最简单的是在游戏站点和联系人站点之间代理消息。
  然而该方案有一些困难：它需要社交网站完全信任游戏网站不会滥用特权，
  或者要求社交网站对每个请求进行验证来确保请求是否被允许
  （例如添加多个联系人、读取联系人、删除联系人等）。
  如果可能有多个游戏同时与联系人提供者通信，还需要额外的复杂性。</p>

  <p>然而，使用消息 Channel 和 <code id=端口作为-web-上对象能力模型的基础:messageport><a href=#messageport>MessagePort</a></code> 对象可以解决所有这些问题。
  当游戏告诉设计网络它需要添加联系人时，社交网站可以请求联系人提供者添加单个联系人的
  <em>能力</em>，而非直接请求添加一个联系人。
  然后联系人提供者提供一对 <code id=端口作为-web-上对象能力模型的基础:messageport-2><a href=#messageport>MessagePort</a></code> 对象，把其中一个返回给社交网站，
  社交网站再把它转交给游戏。游戏和联系人提供者就有了直接的连接，
  因此联系人提供者知道只对它开放 "添加联系人" 的请求。
  换句话说，这个游戏被赋予了添加单个联系人的能力。</p>



  <h5 id=端口作为抽象服务实现的基础><span class=secno>9.5.1.3</span> 端口作为抽象服务实现的基础<a href=#端口作为抽象服务实现的基础 class=self-link></a></h5>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/introduction/ports-as-the-basis-of-abstracting-out-service-implementations.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/introduction/ports-as-the-basis-of-abstracting-out-service-implementations.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <p>继续上一部分提到的例子，特别考虑联系人提供者。
  初始的实现可能是简单地在服务的 <code id=端口作为抽象服务实现的基础:the-iframe-element><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中使用 <code id=端口作为抽象服务实现的基础:xmlhttprequest><a data-x-internal=xmlhttprequest href=https://xhr.spec.whatwg.org/#xmlhttprequest>XMLHttpRequest</a></code> 对象，
  一个改进版本可能会使用 <a href=workers.html#sharedworker id=端口作为抽象服务实现的基础:sharedworker>共享 worker</a>
  和一个 <code id=端口作为抽象服务实现的基础:websocket><a href=web-sockets.html#websocket>WebSocket</a></code> 连接。</p>

  <p>如果初始的设计使用了 <code id=端口作为抽象服务实现的基础:messageport><a href=#messageport>MessagePort</a></code> 对象来赋予能力，或者甚至仅仅是为了支持多个并发的独立会话，
  这个服务的实现就可以直接从
  "每个 <code id=端口作为抽象服务实现的基础:the-iframe-element-2><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> 中一个 <code id=端口作为抽象服务实现的基础:xmlhttprequest-2><a data-x-internal=xmlhttprequest href=https://xhr.spec.whatwg.org/#xmlhttprequest>XMLHttpRequest</a></code>" 模型迁移到
  "共享 <code id=端口作为抽象服务实现的基础:websocket-2><a href=web-sockets.html#websocket>WebSocket</a></code>" 模型，
  完全不需要改变 API：服务提供者一侧的端口可以全部转发到共享 Worker，完全不影响 API 的用户。</p>




  <h4 id=消息通道><span class=secno>9.5.2</span> 消息通道<a href=#消息通道 class=self-link></a></h4>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/message-channels.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/message-channels.en.html></div>

  <pre><code class=idl>[Exposed=(Window,Worker)]
interface <dfn id=messagechannel>MessageChannel</dfn> {
  <a href=#dom-messagechannel id=消息通道:dom-messagechannel>constructor</a>();

  readonly attribute <a href=#messageport id=消息通道:messageport>MessagePort</a> <a href=#dom-messagechannel-port1 id=消息通道:dom-messagechannel-port1>port1</a>;
  readonly attribute <a href=#messageport id=消息通道:messageport-2>MessagePort</a> <a href=#dom-messagechannel-port2 id=消息通道:dom-messagechannel-port2>port2</a>;
};</code></pre>

  <dl class=domintro><dt><var>channel</var> = new <code id=dom-messagechannel-dev><a href=#dom-messagechannel>MessageChannel</a></code>()<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel/MessageChannel title="The MessageChannel() constructor of the MessageChannel interface returns a new MessageChannel object with two new MessagePort objects.">MessageChannel/MessageChannel</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>4.4+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dd>
    <p>返回有两个新的 <code id=消息通道:messageport-3><a href=#messageport>MessagePort</a></code> 对象的，一个新的 <code id=消息通道:messagechannel><a href=#messagechannel>MessageChannel</a></code> 对象。</p>
   <dt><var>channel</var> . <code id=dom-messagechannel-port1-dev><a href=#dom-messagechannel-port1>port1</a></code><div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel/port1 title="The port1 read-only property of the MessageChannel interface returns the first port of the message channel — the port attached to the context that originated the channel.">MessageChannel/port1</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>4.4+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dd>
    <p>返回第一个 <code id=消息通道:messageport-4><a href=#messageport>MessagePort</a></code> 对象。</p>
   <dt><var>channel</var> . <code id=dom-messagechannel-port2-dev><a href=#dom-messagechannel-port2>port2</a></code><div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel/port2 title="The port2 read-only property of the MessageChannel interface returns the second port of the message channel — the port attached to the context at the other end of the channel, which the message is initially sent to.">MessageChannel/port2</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>4.4+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dd>
    <p>返回第二个 <code id=消息通道:messageport-5><a href=#messageport>MessagePort</a></code> 对象。</p>
   </dl>

  

  <p><code id=消息通道:messagechannel-2><a href=#messagechannel>MessageChannel</a></code> 对象有一个关联的 <dfn id=port-1>port 1</dfn> 和 <dfn id=port-2>port 2</dfn>，都是 <code id=消息通道:messageport-6><a href=#messageport>MessagePort</a></code> 对象。</p>

  <p><dfn id=dom-messagechannel><code>new MessageChannel()</code></dfn> 构造步骤为：</p>

  <ol><li><p>设置 <a id=消息通道:this href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-1 id=消息通道:port-1>port 1</a> 为在 <a id=消息通道:this-2 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的
   <a href=webappapis.html#concept-relevant-realm id=消息通道:concept-relevant-realm>相关 Realm</a> 中的 <a id=消息通道:new href=https://heycam.github.io/webidl/#new data-x-internal=new>new</a> <code id=消息通道:messageport-7><a href=#messageport>MessagePort</a></code>。<li><p>设置 <a id=消息通道:this-3 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-2 id=消息通道:port-2>port 2</a> 为在 <a id=消息通道:this-4 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的
   <a href=webappapis.html#concept-relevant-realm id=消息通道:concept-relevant-realm-2>相关 Realm</a> 中的 <a id=消息通道:new-2 href=https://heycam.github.io/webidl/#new data-x-internal=new>new</a> <code id=消息通道:messageport-8><a href=#messageport>MessagePort</a></code>。<li><p><a href=#entangle id=消息通道:entangle>绑定</a> <a id=消息通道:this-5 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-1 id=消息通道:port-1-2>port 1</a> 和 <a id=消息通道:this-6 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-2 id=消息通道:port-2-2>port 2</a>。</ol>

  <p><dfn id=dom-messagechannel-port1><code>port1</code></dfn> 获取步骤为返回 <a id=消息通道:this-7 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-1 id=消息通道:port-1-3>port 1</a>。</p>

  <p><dfn id=dom-messagechannel-port2><code>port2</code></dfn> 获取步骤为返回 <a id=消息通道:this-8 href=https://heycam.github.io/webidl/#this data-x-internal=this>this</a> 的 <a href=#port-2 id=消息通道:port-2-3>port 2</a>。</p>

  




  <h4 id=消息端口><span class=secno>9.5.3</span> 消息端口<a href=#消息端口 class=self-link></a></h4>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/message-ports.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/message-ports.en.html></div>

  <p>每个通道都有两个消息端口。从一个端口发送的数据会从另一个端口收到，反之亦然。</p>

  <pre class=idl>[Exposed=(Window,Worker,AudioWorklet), <a id=消息端口:transferable href=infrastructure.html#transferable>Transferable</a>]
interface <dfn id=messageport>MessagePort</dfn> : <a id=消息端口:eventtarget href=https://dom.spec.whatwg.org/#interface-eventtarget data-x-internal=eventtarget>EventTarget</a> {
  undefined <a href=#dom-messageport-postmessage id=消息端口:dom-messageport-postmessage>postMessage</a>(any message, optional sequence&lt;<a href=https://heycam.github.io/webidl/#idl-object id=消息端口:idl-object data-x-internal=idl-object>object</a>> transfer = []);
  undefined <a href=#dom-messageport-postmessage-options id=消息端口:dom-messageport-postmessage-options>postMessage</a>(any message, optional <a href=#postmessageoptions id=消息端口:postmessageoptions>PostMessageOptions</a> options = {});
  undefined <a href=#dom-messageport-start id=消息端口:dom-messageport-start>start</a>();
  undefined <a href=#dom-messageport-close id=消息端口:dom-messageport-close>close</a>();

  // event handlers
  attribute <a id=消息端口:eventhandler href=webappapis.html#eventhandler>EventHandler</a> <a href=#handler-messageport-onmessage id=消息端口:handler-messageport-onmessage>onmessage</a>;
  attribute <a id=消息端口:eventhandler-2 href=webappapis.html#eventhandler>EventHandler</a> <a href=#handler-messageport-onmessageerror id=消息端口:handler-messageport-onmessageerror>onmessageerror</a>;
};

dictionary <dfn id=postmessageoptions>PostMessageOptions</dfn> {
  sequence&lt;<a href=https://heycam.github.io/webidl/#idl-object id=消息端口:idl-object-2 data-x-internal=idl-object>object</a>> <dfn id=dom-postmessageoptions-transfer>transfer</dfn> = [];
};</pre>

  <dl class=domintro><dt><var>port</var> . <code id=dom-messageport-postmessage-dev><a href=#dom-messageport-postmessage>postMessage</a></code>(<var>message</var> [, <var>transfer</var>] )<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage title="The postMessage() method of the MessagePort interface sends a message from the port, and optionally, transfers ownership of objects to other browsing contexts.">MessagePort/postMessage</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dt><var>port</var> . <code id=dom-messageport-postmessage-options-dev><a href=#dom-messageport-postmessage-options>postMessage</a></code>(<var>message</var> [, { <code>transfer</code> }] )<dd>

    <p>通过通道发布一条消息。列在 <var>transfer</var> 中的对象已经被传输（不仅是克隆），
    意味着在发送侧无法使用了。</p>

    <p>如果 <var>transfer</var> 数组包含重复的对象、源或目标端口时，
    或者 <var>message</var> 不可克隆，
    抛出一个 <a id=消息端口:datacloneerror href=https://heycam.github.io/webidl/#datacloneerror data-x-internal=datacloneerror>"<code>DataCloneError</code>"</a> <code id=消息端口:domexception><a data-x-internal=domexception href=https://heycam.github.io/webidl/#dfn-DOMException>DOMException</a></code>。</p>

   <dt><var>port</var> . <code id=dom-messageport-start-dev><a href=#dom-messageport-start>start</a></code>()<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/start title="The start() method of the MessagePort interface starts the sending of messages queued on the port. This method is only needed when using EventTarget.addEventListener; it is implied when using MessageChannel.onmessage.">MessagePort/start</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dd>

    <p>开始派发端口上收到的消息。</p>

   <dt><var>port</var> . <code id=dom-messageport-close-dev><a href=#dom-messageport-close>close</a></code>()<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/close title="The close() method of the MessagePort interface disconnects the port, so it is no longer active. This stops the flow of messages to that port.">MessagePort/close</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><dd>

    <p>断开端口，端口不再处于激活状态。</p>

   </dl>

  

  <p>每个 <code id=消息端口:messageport><a href=#messageport>MessagePort</a></code> 对象可以与另一个关联（对称关系）。
  每个 <code id=消息端口:messageport-2><a href=#messageport>MessagePort</a></code> 对象也可以有一个 <a href=webappapis.html#task-source id=消息端口:task-source>任务源</a>
  称为 <dfn id=port-message-queue>端口消息队列</dfn>，初始为空。
  <a href=#port-message-queue id=消息端口:port-message-queue>端口消息队列</a> 可以被启用和禁用，初始禁用。
  一旦被启用，就不能再被禁用了
  （虽然队列中的消息可以移动到其他队列或者全部移除，也可以达到一样的效果），
  <code id=消息端口:messageport-3><a href=#messageport>MessagePort</a></code> 还有一个 <dfn id=has-been-shipped>已经被转移</dfn> 标志，
  初始必须为 false。</p>

  <p>当端口的 <a href=#port-message-queue id=消息端口:port-message-queue-2>端口消息队列</a> 被启用时，
  <a href=webappapis.html#event-loop id=消息端口:event-loop>事件循环</a> 不许使用它作为其中一个
  <a href=webappapis.html#task-source id=消息端口:task-source-2>任务源</a>。当端口的
  <a href=webappapis.html#concept-relevant-global id=消息端口:concept-relevant-global>相关全局对象</a> 是 <code id=消息端口:window><a href=window-object.html#window>Window</a></code> 时，
  在它的 <a href=#port-message-queue id=消息端口:port-message-queue-3>端口消息队列</a> 中的所有
  <a href=webappapis.html#concept-task id=消息端口:concept-task>任务</a> 必须与该端口的
  <a href=webappapis.html#concept-relevant-global id=消息端口:concept-relevant-global-2>相关全局对象</a> 的
  <a href=window-object.html#concept-document-window id=消息端口:concept-document-window>关联 <code>Document</code></a> 相关联。</p>

  <p class=note>如果该文档是 <a href=browsers.html#fully-active id=消息端口:fully-active>完全激活的</a>，
  但事件监听器的脚本的 <a href=webappapis.html#settings-object id=消息端口:settings-object>设置对象</a> 指定的 <a href=webappapis.html#responsible-document id=消息端口:responsible-document>负责文档</a> <em>不</em> 是
  <a href=browsers.html#fully-active id=消息端口:fully-active-2>完全激活的</a>，消息会在这些文档
  <a href=browsers.html#fully-active id=消息端口:fully-active-3>完全激活的</a> 时才收到。</p>

  <p>每个 <a href=webappapis.html#event-loop id=消息端口:event-loop-2>事件循环</a> 有一个 <a href=webappapis.html#task-source id=消息端口:task-source-3>任务源</a>
  称为 <dfn id=unshipped-port-message-queue>未转移的端口消息队列</dfn>。
  这是一个虚拟的 <a href=webappapis.html#task-source id=消息端口:task-source-4>任务源</a>，它的必须表现地就像它包含满足以下条件的的每个
  <code id=消息端口:messageport-4><a href=#messageport>MessagePort</a></code> 的 <a href=#port-message-queue id=消息端口:port-message-queue-4>端口消息队列</a> 的所有 <a href=webappapis.html#concept-task id=消息端口:concept-task-2>任务</a> 一样：
  1. <a href=#has-been-shipped id=消息端口:has-been-shipped>已经被转移</a> 标志位 false；
  2. 启用了 <a href=#port-message-queue id=消息端口:port-message-queue-5>端口消息队列</a>；
  3. <a href=webappapis.html#relevant-agent id=消息端口:relevant-agent>相关代理</a> 的 <a href=webappapis.html#concept-agent-event-loop id=消息端口:concept-agent-event-loop>事件循环</a> 为该 <a href=webappapis.html#event-loop id=消息端口:event-loop-3>事件循环</a>。
  顺序为它们被添加到对应的 <a href=webappapis.html#task-source id=消息端口:task-source-5>任务源</a> 的顺序。
  当 <a href=webappapis.html#concept-task id=消息端口:concept-task-3>任务</a> 从 <a href=#unshipped-port-message-queue id=消息端口:unshipped-port-message-queue>未转移的端口消息队列</a> 移除时，
  它必须也从它的 <a href=#port-message-queue id=消息端口:port-message-queue-6>端口消息队列</a> 中移除。</p>

  <p>当 <code id=消息端口:messageport-5><a href=#messageport>MessagePort</a></code> 的 <a href=#has-been-shipped id=消息端口:has-been-shipped-2>已被转移</a> 标志为 false 时，
  <a href=webappapis.html#event-loop id=消息端口:event-loop-4>事件循环</a> 必须忽略它的
  <a href=#port-message-queue id=消息端口:port-message-queue-7>端口消息队列</a>
  （此时使用 <a href=#unshipped-port-message-queue id=消息端口:unshipped-port-message-queue-2>未转移的端口消息队列</a>）。</p>

  <p class=note>
  当一个端口、其关联端口、或者它克隆自的对象被传输时，
  <a href=#has-been-shipped id=消息端口:has-been-shipped-3>已被转移</a> 标志位设为 true
  当 <code id=消息端口:messageport-6><a href=#messageport>MessagePort</a></code> 的 <a href=#has-been-shipped id=消息端口:has-been-shipped-4>已被转移</a> 标志为 true 时，
  其 <a href=#port-message-queue id=消息端口:port-message-queue-8>端口消息队列</a> 是一级
  <a href=webappapis.html#task-source id=消息端口:task-source-6>任务源</a>，不受任何
  <a href=#unshipped-port-message-queue id=消息端口:unshipped-port-message-queue-3>未转移的端口消息队列</a> 影响。</p>

  <p>当用户代理 <dfn id=entangle>关联</dfn> 两个 <code id=消息端口:messageport-7><a href=#messageport>MessagePort</a></code> 对象时，
  必须执行以下步骤：</p>

  <ol><li>
    <p>如果其中给一个端口已经关联，则把它与之前关联的端口解关联。</p>

    <p class=note>如果那两个之前关联的端口是同一个
    <code id=消息端口:messagechannel><a href=#messagechannel>MessageChannel</a></code> 对象的两个端口，则那个 <code id=消息端口:messagechannel-2><a href=#messagechannel>MessageChannel</a></code>
    对象不再表示任何真正的端口：它的两个端口已经不再关联。</p>
   <li>
    <p>关联这两个端口，让它们组成新通道的两部分。
    （没有 <code id=消息端口:messagechannel-3><a href=#messagechannel>MessageChannel</a></code> 对象表示这个通道）</p>

    <p>经过这个步骤的两个端口 <var>A</var> 和 <var>B</var>
    被称为关联的；其中一个关联到了另一个，反之亦然。</p>

    <p class=note>尽管本标准把这个过程描述为瞬间的，但它们更有可能通过消息传递来实现。
    就像其他所有算法一样，关键是只要最终结果无法与规范区分（在黑盒的意义上）。</p>
   </ol>

  <hr>

  <p id=transferMessagePort><code id=消息端口:messageport-8><a href=#messageport>MessagePort</a></code> 对象是
  <a href=infrastructure.html#可传输对象 id=消息端口:可传输对象>可传输对象</a>。
  给定 <var>value</var> 和 <var>dataHolder</var>，
  它们的 <a href=infrastructure.html#transfer-steps id=消息端口:transfer-steps>传输步骤</a> 是：</p>

  <ol><li><p>设置 <var>value</var> 的 <a href=#has-been-shipped id=消息端口:has-been-shipped-5>已被转移</a> 标志为 true。<li><p>设置 <var>dataHolder</var>.[[PortMessageQueue]] 到 <var>value</var> 的
   <a href=#port-message-queue id=消息端口:port-message-queue-9>端口消息队列</a>。<li>
    <p>如果 <var>value</var> 与另一个端口 <var>remotePort</var> 关联，则：</p>

    <ol><li><p>设置 <var>remotePort</var> 的 <a href=#has-been-shipped id=消息端口:has-been-shipped-6>已被转移</a> 标志为 true。<li><p>设置 <var>dataHolder</var>.[[RemotePort]] 为 <var>remotePort</var>。</ol>
   <li><p>否则，设置 <var>dataHolder</var>.[[RemotePort]] 为 null。</ol>

  <p>给定 <var>dataHolder</var> 和 <var>value</var>，
  它们的 <a href=infrastructure.html#transfer-receiving-steps id=消息端口:transfer-receiving-steps>传输-接收步骤</a> 是：</p>

  <ol><li><p>设置 <var>value</var> 的 <a href=#has-been-shipped id=消息端口:has-been-shipped-7>已被转移</a> 标志为 true。<li><p>把所有要在 <var>dataHolder</var>.[[PortMessageQueue]] 上触发
   <code id=消息端口:event-message><a href=indices.html#event-message>message</a></code> 事件的
   <a href=webappapis.html#concept-task id=消息端口:concept-task-4>tasks</a>（如果有的话）
   移动到
   <var>value</var> 的 <a href=#port-message-queue id=消息端口:port-message-queue-10>端口消息队列</a> 上，
   保持 <var>value</var> 的 <a href=#port-message-queue id=消息端口:port-message-queue-11>端口消息队列</a> 处于初始的禁用状态，
   如果 <var>value</var> 的 <a href=webappapis.html#concept-relevant-global id=消息端口:concept-relevant-global-3>相关全局对象</a> 是 <code id=消息端口:window-2><a href=window-object.html#window>Window</a></code>，
   将移动后的 <a href=webappapis.html#concept-task id=消息端口:concept-task-5>任务</a> 与 <var>value</var> 的
   <a href=webappapis.html#concept-relevant-global id=消息端口:concept-relevant-global-4>相关全局对象</a> 的
   <a href=window-object.html#concept-document-window id=消息端口:concept-document-window-2>关联 <code>Document</code></a> 相关联。<li><p>如果 <var>dataHolder</var>.[[RemotePort]] 非 null，则 <a href=#entangle id=消息端口:entangle>关联</a>
   <var>dataHolder</var>.[[RemotePort]] 和 <var>value</var>。（这将会把
   <var>dataHolder</var>.[[RemotePort]] 与它之前关联的被转移的端口解关联）。
  </ol>

  <hr>

  <p>给定 <var>targetPort</var>，<var>message</var> 和 <var>options</var>，
  <dfn id=message-port-post-message-steps>消息端口发消息的步骤</dfn> 如下：</p>

  <ol><li><p>令 <var>transfer</var> 为 <var>options</var>["<code id=消息端口:dom-postmessageoptions-transfer><a href=#dom-postmessageoptions-transfer>transfer</a></code>"]。<li><p>如果在 <var>transfer</var> 中的任何一个对象是这个 <code id=消息端口:messageport-9><a href=#messageport>MessagePort</a></code>，
   则抛出一个 <a id=消息端口:datacloneerror-2 href=https://heycam.github.io/webidl/#datacloneerror data-x-internal=datacloneerror>"<code>DataCloneError</code>"</a> <code id=消息端口:domexception-2><a data-x-internal=domexception href=https://heycam.github.io/webidl/#dfn-DOMException>DOMException</a></code>。<li><p>令 <var>doomed</var> 为 false。<li><p>如果 <var>targetPort</var> 非 null 且 <var>transfer</var> 中有任何对象是
   <var>targetPort</var>，则设置 <var>doomed</var> 为 true，并（可选地）在开发终端中报告
   目标端口被发送到了它自己，导致通道丢失。<li><p>令 <var>serializeWithTransferResult</var> 为
   <a id=消息端口:structuredserializewithtransfer href=infrastructure.html#structuredserializewithtransfer>StructuredSerializeWithTransfer</a>(<var>message</var>, <var>transfer</var>)。
   重新抛出任何异常。<li><p>如果没有 <var>targetPort</var> （比如这个 <code id=消息端口:messageport-10><a href=#messageport>MessagePort</a></code> 未关联），
   或者如果 <var>doomed</var> 为 true，则返回。<li>
    <p>在 <var>targetPort</var> 的 <a href=#port-message-queue id=消息端口:port-message-queue-12>端口消息队列</a>
    中添加一个 <a href=webappapis.html#concept-task id=消息端口:concept-task-6>任务</a> 执行以下步骤：</p>

    <ol><li>
      <p>令 <var>finalTargetPort</var> 为在当前任务所在的
      <a href=#port-message-queue id=消息端口:port-message-queue-13>端口消息队列</a> 的 <code id=消息端口:messageport-11><a href=#messageport>MessagePort</a></code>。</p>

      <p class=note>这可能与 <var>targetPort</var> 不同，如果 <var>targetPort</var>
      自己被传输，它的所有任务都跟着移动。</p>
     <li><p>令 <var>targetRealm</var> 为 <var>finalTargetPort</var> 的 <a href=webappapis.html#concept-relevant-realm id=消息端口:concept-relevant-realm>相关 Realm</a>。<li>
      <p>令 <var>deserializeRecord</var> 为
      <a id=消息端口:structureddeserializewithtransfer href=infrastructure.html#structureddeserializewithtransfer>StructuredDeserializeWithTransfer</a>(<var>serializeWithTransferResult</var>,
      <var>targetRealm</var>)。</p>

      <p>如果这抛出了异常，捕获它并在
      <var>finalTargetPort</var> 上用 <code id=消息端口:messageevent><a href=comms.html#messageevent>MessageEvent</a></code>
      <a href=https://dom.spec.whatwg.org/#concept-event-fire id=消息端口:concept-event-fire data-x-internal=concept-event-fire>触发一个</a>
      名为 <code id=消息端口:event-messageerror><a href=indices.html#event-messageerror>messageerror</a></code> 的事件，然后返回。
     <li><p>令 <var>messageClone</var> 为 <var>deserializeRecord</var>.[[Deserialized]]。<li><p>令 <var>newPorts</var> 为一个新的 <a href=https://heycam.github.io/webidl/#dfn-frozen-array-type id=消息端口:frozen-array data-x-internal=frozen-array>冻结的数组</a>
     该数组包含所有 <var>deserializeRecord</var>.[[TransferredValues]] 中的
     <code id=消息端口:messageport-12><a href=#messageport>MessagePort</a></code> 对象（如果有的话），保持它们的相对顺序。<li><p>在 <var>finalTargetPort</var> 上用 <code id=消息端口:messageevent-2><a href=comms.html#messageevent>MessageEvent</a></code>,
     <a href=https://dom.spec.whatwg.org/#concept-event-fire id=消息端口:concept-event-fire-2 data-x-internal=concept-event-fire>触发一个</a> 名为 <code id=消息端口:event-message-2><a href=indices.html#event-message>message</a></code>
     的事件，其 <code id=消息端口:dom-messageevent-data><a href=comms.html#dom-messageevent-data>data</a></code> 属性初始化为
     <var>messageClone</var> 且 <code id=消息端口:dom-messageevent-ports><a href=comms.html#dom-messageevent-ports>ports</a></code>
     属性初始化为<var>newPorts</var>。</ol>
   </ol>

  <p>在 <code id=消息端口:messageport-13><a href=#messageport>MessagePort</a></code> 对象上调用
  <dfn id=dom-messageport-postmessage-options><code>postMessage(<var>message</var>,
  <var>options</var>)</code></dfn> 方法时，执行以下步骤：</p>

  <ol><li><p>令 <var>targetPort</var> 为 <code id=消息端口:messageport-14><a href=#messageport>MessagePort</a></code> 绑定的端口（如果有的话），
   如果没有就令它为 null。<li><p>用 <var>targetPort</var>，<var>message</var> 和 <var>options</var>
   执行 <a href=#message-port-post-message-steps id=消息端口:message-port-post-message-steps>消息端口发送消息步骤</a>。</ol>

  <p>在 <code id=消息端口:messageport-15><a href=#messageport>MessagePort</a></code> 对象上调用
  <dfn id=dom-messageport-postmessage><code>postMessage(<var>message</var>,
  <var>transfer</var>)</code></dfn> 方法时必须执行以下步骤：</p>

  <ol><li><p>令 <var>targetPort</var> 为 <code id=消息端口:messageport-16><a href=#messageport>MessagePort</a></code> 绑定的端口（如果有的话），
   如果没有就令它为 null。<li><p>令 <var>options</var> 为 «[ "<code id=消息端口:dom-postmessageoptions-transfer-2><a href=#dom-postmessageoptions-transfer>transfer</a></code>" → <var>transfer</var> ]»。<li><p>用 <var>targetPort</var>，<var>message</var> 和 <var>options</var>
   执行 <a href=#message-port-post-message-steps id=消息端口:message-port-post-message-steps-2>消息端口发送消息步骤</a>。</ol>

  <hr>

  <p><dfn id=dom-messageport-start><code>start()</code></dfn> 方法必须启用其端口的
  <a href=#port-message-queue id=消息端口:port-message-queue-14>端口消息队列</a>，如果还没有启用的话。</p>

  <hr>

  <p>
  在已关联的端口 <var>local port</var> 上调用
  <dfn id=dom-messageport-close><code>close()</code></dfn> 方法时，
  用户代理必须解关联这两个端口。
  如果该方法在一个未关联的端口上调用时，该方法必须什么都不做。</p>

  <hr>

  <p>下面是所有实现 <code id=消息端口:messageport-17><a href=#messageport>MessagePort</a></code> 接口的对象 必须 支持的
  <a href=webappapis.html#event-handlers id=消息端口:event-handlers>事件处理器</a>
  （以及它们相应的<a href=webappapis.html#event-handler-event-type id=消息端口:event-handler-event-type>事件处理器事件类型</a>），
  作为 <a href=webappapis.html#event-handler-idl-attributes id=消息端口:event-handler-idl-attributes>事件处理器 IDL 属性</a>：</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=消息端口:event-handlers-2>事件处理器</a> <th><a href=webappapis.html#event-handler-event-type id=消息端口:event-handler-event-type-2>事件处理器事件类型</a>
   <tbody><tr><td><dfn id=handler-messageport-onmessage><code>onmessage</code></dfn> <div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><b title="Support in all current engines." class=all-engines-flag>✔</b><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage title="The onmessage event handler of the MessagePort interface is an EventListener, called whenever an MessageEvent of type message is fired on the port — that is, when the port receives a message.">MessagePort/onmessage</a><p class=all-engines-text>Support in all current engines.<div class=support><span class="firefox yes"><span>Firefox</span><span>41+</span></span><span class="safari yes"><span>Safari</span><span>5+</span></span><span class="chrome yes"><span>Chrome</span><span>4+</span></span><hr><span class="opera yes"><span>Opera</span><span>10.6+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>12+</span></span><span class="ie yes"><span>Internet Explorer</span><span>10+</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>41+</span></span><span class="safari_ios yes"><span>Safari iOS</span><span>5.1+</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>18+</span></span><span class="webview_android yes"><span>WebView Android</span><span>37+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>1.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>11+</span></span></div></div></div><td> <code id=消息端口:event-message-3><a href=indices.html#event-message>message</a></code>
    <tr><td><dfn id=handler-messageport-onmessageerror><code>onmessageerror</code></dfn> <div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessageerror title="The onmessageerror event handler of the MessagePort interface is an EventListener, called whenever an MessageEvent of type messageerror is fired on the port—that is, when it receives a message that cannot be deserialized.">MessagePort/onmessageerror</a><div class=support><span class="firefox yes"><span>Firefox</span><span>57+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>60+</span></span><hr><span class="opera yes"><span>Opera</span><span>47+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge yes"><span>Edge (Legacy)</span><span>18</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>57+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>60+</span></span><span class="webview_android yes"><span>WebView Android</span><span>60+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>8.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>44+</span></span></div></div></div><td> <code id=消息端口:event-messageerror-2><a href=indices.html#event-messageerror>messageerror</a></code>
  </table>

  <p>第一次设置 <code id=消息端口:messageport-18><a href=#messageport>MessagePort</a></code> 对象的
  <code id=消息端口:handler-messageport-onmessage-2><a href=#handler-messageport-onmessage>onmessage</a></code> IDL 属性时，
  端口的 <a href=#port-message-queue id=消息端口:port-message-queue-15>端口消息队列</a> 必须被启用，
  就像调用了 <code id=消息端口:dom-messageport-start-2><a href=#dom-messageport-start>start()</a></code> 方法一样。</p>

  



  <h4 id=广播给多个端口><span class=secno>9.5.4</span> 广播给多个端口<a href=#广播给多个端口 class=self-link></a></h4>
<div data-zh-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" data-en-date="Thu Mar 01 2018 15:51:30 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/broadcasting-to-many-ports.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/broadcasting-to-many-ports.en.html></div>

  <p><i>This section is non-normative.</i></p>

  <p>B广播给多个端口原则上相对简单：维护一个要发消息的
  <code id=广播给多个端口:messageport><a href=#messageport>MessagePort</a></code> 对象数组，发消息时遍历这个数组。
  然而这有一个不好的效果：它会阻止端口的垃圾回收，即使另一端已经走了。
  为了避免这个问题，实现一个简单的协议让对方确认它还存在。
  如果它在某段时间没有确认，就假设它已经不在了，关闭
  <code id=广播给多个端口:messageport-2><a href=#messageport>MessagePort</a></code> 对象并让它被回收。</p>



  <h4 id=ports-and-garbage-collection><span class=secno>9.5.5</span> 端口与垃圾回收<a href=#ports-and-garbage-collection class=self-link></a></h4>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/channel-messaging/ports-and-garbage-collection.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/channel-messaging/ports-and-garbage-collection.en.html></div>

  

  <p>当一个 <code id=ports-and-garbage-collection:messageport><a href=#messageport>MessagePort</a></code> 对象 <var>o</var> 被关联时，用户代理的表现必须像是
  <var>o</var> 的关联 <code id=ports-and-garbage-collection:messageport-2><a href=#messageport>MessagePort</a></code> 对象有一个 <var>o</var> 的强引用。
  或者就像 <var>o</var> 的 <a href=webappapis.html#concept-relevant-global id=ports-and-garbage-collection:concept-relevant-global>相关全局对象</a> 有一个
  <var>o</var> 的强引用。</p>

  <div class=note>

   <p>这样给定一个事件监听器，它收到一个消息端口后可以忘掉它。
   只要该事件监听器还可能收到消息，这个通道就仍然被维护着。</p>

   <p>当然这在通道的两侧都会发生，只要它们不能从活跃的代码到达，两个端口就都会被垃圾回收。
   即使它们之间还有对方的强引用。</p>

  </div>

  <p>进一步地，当
  <a href=webappapis.html#task-queue id=ports-and-garbage-collection:task-queue>任务队列</a> 中的 <a href=webappapis.html#concept-task id=ports-and-garbage-collection:concept-task>任务</a>
  仍然有一个要派发在 <code id=ports-and-garbage-collection:messageport-3><a href=#messageport>MessagePort</a></code> 上的事件时，
  或者这个 <code id=ports-and-garbage-collection:messageport-4><a href=#messageport>MessagePort</a></code> 对象的
  <a href=#port-message-queue id=ports-and-garbage-collection:port-message-queue>端口消息队列</a> 处于启用状态且非空时，
  <code id=ports-and-garbage-collection:messageport-5><a href=#messageport>MessagePort</a></code> 对象不得被垃圾回收。
 </p>
  

  

  

  <p class=note>强烈鼓励作者显式地关闭 <code id=ports-and-garbage-collection:messageport-6><a href=#messageport>MessagePort</a></code> 对象来解关联它们，
  这样它们的资源可以被重新回收。
  创建很多歌 <code id=ports-and-garbage-collection:messageport-7><a href=#messageport>MessagePort</a></code> 对象并直接丢弃它们而不关闭可能导致瞬时内存使用率高，
  因为垃圾收集不一定能够及时执行，尤其是对于垃圾收集可能涉及跨进程协调的
  <code id=ports-and-garbage-collection:messageport-8><a href=#messageport>MessagePort</a></code> 而言。</p>




  <h3 id=向其他浏览上下文广播><span class=secno>9.6</span> <dfn>向其他浏览上下文广播</dfn><a href=#向其他浏览上下文广播 class=self-link></a></h3>
<div data-zh-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" data-en-date="Wed Nov 04 2020 06:47:17 GMT+0000 (UTC)" class=translate-info data-zh-file=https://github.com/whatwg-cn/html/edit/master/src/communication/broadcasting-to-other-browsing-contexts.zh.html data-en-file=https://github.com/whatwg-cn/html/blob/master/src/communication/broadcasting-to-other-browsing-contexts.en.html></div>

  <p>同一个用户，同一个用户代理，同一个 <a href=origin.html#concept-origin id=向其他浏览上下文广播:concept-origin>域</a>，
  但不同 <a href=browsers.html#browsing-context id=向其他浏览上下文广播:browsing-context>浏览上下文</a> 的页面有时需要相互发送通知，
  例如 “嘿，用户在我这里登录了，重新检查你的信任状态”。</p>

  <p>对于复杂情况，例如管理共享状态的锁定，管理服务器和多个本地客户端之间的资源同步，
  共享与远程主机的 <code id=向其他浏览上下文广播:websocket><a href=web-sockets.html#websocket>WebSocket</a></code> 连接等等，
  <a href=workers.html#sharedworker id=向其他浏览上下文广播:sharedworker>共享 Worker</a> 是最合适的解决方案。</p>

  <p>但对于简单情况，共享 Worker 可能是不合理的开销，
  作者可以使用这一章描述的简单的基于通道的广播机制。</p>

  <pre class=idl>[<a href=#dom-broadcastchannel id=向其他浏览上下文广播:dom-broadcastchannel>Constructor</a>(DOMString name), Exposed=(Window,Worker)]
interface <dfn id=broadcastchannel>BroadcastChannel</dfn> : <a id=向其他浏览上下文广播:eventtarget href=https://dom.spec.whatwg.org/#interface-eventtarget data-x-internal=eventtarget>EventTarget</a> {
  readonly attribute DOMString <a href=#dom-broadcastchannel-name id=向其他浏览上下文广播:dom-broadcastchannel-name>name</a>;
  void <a href=#dom-broadcastchannel-postmessage id=向其他浏览上下文广播:dom-broadcastchannel-postmessage>postMessage</a>(any message);
  void <a href=#dom-broadcastchannel-close id=向其他浏览上下文广播:dom-broadcastchannel-close>close</a>();
  attribute <a id=向其他浏览上下文广播:eventhandler href=webappapis.html#eventhandler>EventHandler</a> <a href=#handler-broadcastchannel-onmessage id=向其他浏览上下文广播:handler-broadcastchannel-onmessage>onmessage</a>;
  attribute <a id=向其他浏览上下文广播:eventhandler-2 href=webappapis.html#eventhandler>EventHandler</a> <a href=#handler-broadcastchannel-onmessageerror id=向其他浏览上下文广播:handler-broadcastchannel-onmessageerror>onmessageerror</a>;
};</pre>

  <dl class=domintro><dt><var>broadcastChannel</var> = new <code id=dom-broadcastchannel-dev><a href=#dom-broadcastchannel>BroadcastChannel</a></code>(<var>name</var>)<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/BroadcastChannel title="The BroadcastChannel() constructor creates a new BroadcastChannel and connects it to the underlying channel.">BroadcastChannel/BroadcastChannel</a><div class=support><span class="firefox yes"><span>Firefox</span><span>38+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera yes"><span>Opera</span><span>41+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>38+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>54+</span></span><span class="webview_android yes"><span>WebView Android</span><span>54+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>6.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>41+</span></span></div></div></div><dd>

    <p>返回一个新的 <code id=向其他浏览上下文广播:broadcastchannel><a href=#broadcastchannel>BroadcastChannel</a></code> 对象，通过它可以像指定的通道名发送和接收消息。</p>

   <dt><var>broadcastChannel</var> . <code id=dom-broadcastchannel-name-dev><a href=#dom-broadcastchannel-name>name</a></code><div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/name title="The read-only BroadcastChannel.name property returns a DOMString, which uniquely identifies the given channel with its name. This name is passed to the BroadcastChannel() constructor at creation time and is therefore read-only.">BroadcastChannel/name</a><div class=support><span class="firefox yes"><span>Firefox</span><span>38+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera yes"><span>Opera</span><span>41+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>38+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>54+</span></span><span class="webview_android yes"><span>WebView Android</span><span>54+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>6.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>41+</span></span></div></div></div><dd>

    <p>返回通道名（传递给构造函数的）。</p>

   <dt><var>broadcastChannel</var> . <code id=dom-broadcastchannel-postmessage-dev><a href=#dom-broadcastchannel-postmessage>postMessage</a></code>(<var>message</var>)<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/postMessage title="The BroadcastChannel.postMessage() sends a message, which can be of any kind of Object, to each listener in any browsing context with the same origin. The message is transmitted as a message event targeted at each BroadcastChannel bound to the channel.">BroadcastChannel/postMessage</a><div class=support><span class="firefox yes"><span>Firefox</span><span>38+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera yes"><span>Opera</span><span>41+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>38+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>54+</span></span><span class="webview_android yes"><span>WebView Android</span><span>54+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>6.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>41+</span></span></div></div></div><dd>

    <p>向为这个通道建立的 <code id=向其他浏览上下文广播:broadcastchannel-2><a href=#broadcastchannel>BroadcastChannel</a></code> 对象发送给定的消息。
    消息可以是结构化对象，例如嵌套对象和数组。</p>

   <dt><var>broadcastChannel</var> . <code id=dom-broadcastchannel-close-dev><a href=#dom-broadcastchannel-close>close</a></code>()<div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/close title="The BroadcastChannel.close() terminates the connection to the underlying channel, allowing the object to be garbage collected. This is a necessary step to perform as there is no other way for a browser to know that this channel is not needed anymore.">BroadcastChannel/close</a><div class=support><span class="firefox yes"><span>Firefox</span><span>38+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera yes"><span>Opera</span><span>41+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>38+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>54+</span></span><span class="webview_android yes"><span>WebView Android</span><span>54+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>6.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>41+</span></span></div></div></div><dd>

    <p>关闭 <code id=向其他浏览上下文广播:broadcastchannel-3><a href=#broadcastchannel>BroadcastChannel</a></code> 对象，让它可以被垃圾回收。</p>

   </dl>

  

  <p><code id=向其他浏览上下文广播:broadcastchannel-4><a href=#broadcastchannel>BroadcastChannel</a></code> 对象有一个 <dfn id=channel-name>通道名</dfn>，
  一个 <dfn id=broadcastchannel-settings-object><code>BroadcastChannel</code> 设置对象</dfn>，
  以及一个 <dfn id=concept-broadcastchannel-closed>关闭标志</dfn>。</p>

  <p><dfn id=dom-broadcastchannel><code>BroadcastChannel()</code></dfn> 构造函数被调用时，
  必须创建和返回一个 <code id=向其他浏览上下文广播:broadcastchannel-5><a href=#broadcastchannel>BroadcastChannel</a></code> 对象，
  其 <a href=#channel-name id=向其他浏览上下文广播:channel-name>通道名</a> 为构造函数的第一个参数，
  其 <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object><code>BroadcastChannel</code> 设置对象</a>
  为 <a href=webappapis.html#incumbent-settings-object id=向其他浏览上下文广播:incumbent-settings-object>当前设置对象</a>，
  其 <a href=#concept-broadcastchannel-closed id=向其他浏览上下文广播:concept-broadcastchannel-closed>关闭标志</a> 为 false。</p>

  <p><dfn id=dom-broadcastchannel-name><code>name</code></dfn> 属性必须返回
  <a href=#channel-name id=向其他浏览上下文广播:channel-name-2>通道名</a>。</p>

  <p><dfn id=dom-broadcastchannel-postmessage><code>postMessage(<var>message</var>)</code></dfn> 方法在
  <code id=向其他浏览上下文广播:broadcastchannel-6><a href=#broadcastchannel>BroadcastChannel</a></code> 对象上被调用时,必须执行以下步骤：</p>

  <ol><li><p>令 <var>source</var> 为这个 <code id=向其他浏览上下文广播:broadcastchannel-7><a href=#broadcastchannel>BroadcastChannel</a></code>。<li><p>令 <var>sourceSettings</var> 为 <var>source</var> 的
   <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-2><code>BroadcastChannel</code> 设置对象</a>。<li><p>如果 <var>source</var> 的 <a href=#concept-broadcastchannel-closed id=向其他浏览上下文广播:concept-broadcastchannel-closed-2>关闭标志</a>
   为 true，则抛出一个 <a id=向其他浏览上下文广播:invalidstateerror href=https://heycam.github.io/webidl/#invalidstateerror data-x-internal=invalidstateerror>"<code>InvalidStateError</code>"</a> <code id=向其他浏览上下文广播:domexception><a data-x-internal=domexception href=https://heycam.github.io/webidl/#dfn-DOMException>DOMException</a></code>。<li><p>令 <var>sourceChannel</var> 为 <var>source</var> 的 <a href=#channel-name id=向其他浏览上下文广播:channel-name-3>通道名</a>。<li><p>令 <var>targetRealm</var> 为用户代理定义的 Realm。<li><p>令 <var>serialized</var> 为 <a id=向其他浏览上下文广播:structuredserialize href=infrastructure.html#structuredserialize>StructuredSerialize</a>(<var>message</var>)。
   重新抛出任何异常。<li>
    <p>令 <var>destinations</var> 为符合以下要求的 <code id=向其他浏览上下文广播:broadcastchannel-8><a href=#broadcastchannel>BroadcastChannel</a></code> 对象的列表：</p>

    <ul><li>
      <p>其 <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-3><code>BroadcastChannel</code> 设置对象</a> 指定了以下之一：</p>

      <ul><li><p>一个 <code id=向其他浏览上下文广播:window><a href=window-object.html#window>Window</a></code> <a href=webappapis.html#concept-settings-object-global id=向其他浏览上下文广播:concept-settings-object-global>全局对象</a>，
       以及一个 <a href=browsers.html#fully-active id=向其他浏览上下文广播:fully-active>完全激活的</a>
       <a href=webappapis.html#responsible-document id=向其他浏览上下文广播:responsible-document>负责文档</a>，或<li><p>一个 <code id=向其他浏览上下文广播:workerglobalscope><a href=workers.html#workerglobalscope>WorkerGlobalScope</a></code>
       <a href=webappapis.html#concept-settings-object-global id=向其他浏览上下文广播:concept-settings-object-global-2>全局对象</a>
       且它的 <a href=workers.html#dom-workerglobalscope-closing id=向其他浏览上下文广播:dom-workerglobalscope-closing>正则关闭</a> 标志为 false，
       且它的 <a id=向其他浏览上下文广播:worker href=workers.html#worker>worker</a> 不是一个 <a href=workers.html#suspendable-worker id=向其他浏览上下文广播:suspendable-worker>可终止的 Worker</a>。</ul>
     <li><p>它们的 <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-4><code>BroadcastChannel</code> 设置对象</a> 的 <a href=webappapis.html#concept-settings-object-origin id=向其他浏览上下文广播:concept-settings-object-origin>源</a> 与
     <var>sourceSettings</var> 的 <a href=webappapis.html#concept-settings-object-origin id=向其他浏览上下文广播:concept-settings-object-origin-2>源</a>
     <a href=origin.html#same-origin id=向其他浏览上下文广播:same-origin>同源</a>。<li><p>它们的 <a href=#channel-name id=向其他浏览上下文广播:channel-name-4>通道名</a>
     大消息敏感地匹配<var>sourceChannel</var>。<li><p>它们的 <a href=#concept-broadcastchannel-closed id=向其他浏览上下文广播:concept-broadcastchannel-closed-3>已关闭标志</a> 为 false。</ul>
   <li><p>从 <var>destinations</var> 移除 <var>source</var>。<li><p>将 <var>destinations</var> 排序，使得所有
   <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-5><code>BroadcastChannel</code> 设置对象</a>
   指定了同样
   <a href=webappapis.html#responsible-event-loop id=向其他浏览上下文广播:responsible-event-loop>负责事件循环</a> 的
   <code id=向其他浏览上下文广播:broadcastchannel-9><a href=#broadcastchannel>BroadcastChannel</a></code> 对象按照创建顺序排序，老的在先。
   （这并没有定义完全排序。在这个约束下，用户代理可以按任意方式排序）<li>
    <p>对 <var>destinations</var> 中的每一个 <code id=向其他浏览上下文广播:broadcastchannel-10><a href=#broadcastchannel>BroadcastChannel</a></code> 对象 <var>destination</var>，
    <a href=webappapis.html#queue-a-task id=向其他浏览上下文广播:queue-a-task>排一个任务</a> 执行以下步骤：</p>

    <ol><li><p>令 <var>targetRealm</var> 为 <var>destination</var> 的 <a href=webappapis.html#concept-relevant-realm id=向其他浏览上下文广播:concept-relevant-realm>相关 Realm</a>。<li>
      <p>令 <var>data</var> 为 <a id=向其他浏览上下文广播:structureddeserialize href=infrastructure.html#structureddeserialize>StructuredDeserialize</a>(<var>serialized</var>,
      <var>targetRealm</var>)。</p>

      <p>如果抛出了异常，捕获它，在 <var>destination</var> 上使用 <code id=向其他浏览上下文广播:messageevent><a href=comms.html#messageevent>MessageEvent</a></code>
      <a href=https://dom.spec.whatwg.org/#concept-event-fire id=向其他浏览上下文广播:concept-event-fire data-x-internal=concept-event-fire>发生</a> 一个名为
      <code id=向其他浏览上下文广播:event-messageerror><a href=indices.html#event-messageerror>messageerror</a></code> 的事件，
      <code id=向其他浏览上下文广播:dom-messageevent-origin><a href=comms.html#dom-messageevent-origin>origin</a></code> 属性初始化为
      <var>sourceSettings</var> 的 <a href=webappapis.html#concept-settings-object-origin id=向其他浏览上下文广播:concept-settings-object-origin-3>origin</a> 的
      <a href=origin.html#ascii-serialisation-of-an-origin id=向其他浏览上下文广播:ascii-serialisation-of-an-origin>序列化</a>，然后返回。</p>
     <li><p>在 <var>destination</var> 上使用 <code id=向其他浏览上下文广播:messageevent-2><a href=comms.html#messageevent>MessageEvent</a></code>
     <a href=https://dom.spec.whatwg.org/#concept-event-fire id=向其他浏览上下文广播:concept-event-fire-2 data-x-internal=concept-event-fire>发生</a> 一个名为 <code id=向其他浏览上下文广播:event-message><a href=indices.html#event-message>message</a></code>
     的事件，其 <code id=向其他浏览上下文广播:dom-messageevent-data><a href=comms.html#dom-messageevent-data>data</a></code> 属性初始化为 <var>data</var>，
     <code id=向其他浏览上下文广播:dom-messageevent-origin-2><a href=comms.html#dom-messageevent-origin>origin</a></code> 属性初始化为
     <var>sourceSettings</var> 的 <a href=webappapis.html#concept-settings-object-origin id=向其他浏览上下文广播:concept-settings-object-origin-4>origin</a> 的
     <a href=origin.html#ascii-serialisation-of-an-origin id=向其他浏览上下文广播:ascii-serialisation-of-an-origin-2>序列化</a>。</ol>

    <p><a href=webappapis.html#concept-task id=向其他浏览上下文广播:concept-task>任务</a> 必须使用
    <a href=webappapis.html#dom-manipulation-task-source id=向其他浏览上下文广播:dom-manipulation-task-source>DOM 操作任务源</a>，
    而且对于那些目标 <code id=向其他浏览上下文广播:broadcastchannel-11><a href=#broadcastchannel>BroadcastChannel</a></code> 对象的
    <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-6><code>BroadcastChannel</code> 设置对象</a>
    指定的 <a href=webappapis.html#event-loop id=向其他浏览上下文广播:event-loop>事件循环</a>
    是一个 <a href=browsers.html#browsing-context id=向其他浏览上下文广播:browsing-context-2>浏览上下文</a>
    <a href=webappapis.html#event-loop id=向其他浏览上下文广播:event-loop-2>事件循环</a> 的任务，必须与
    那个目标的 <code id=向其他浏览上下文广播:broadcastchannel-12><a href=#broadcastchannel>BroadcastChannel</a></code> 对象的
    <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-7><code>BroadcastChannel</code> 设置对象</a>
    指定的 <a href=webappapis.html#responsible-document id=向其他浏览上下文广播:responsible-document-2>负责文档</a> 相关联。</p>
   </ol>

  <p>当 <a href=#concept-broadcastchannel-closed id=向其他浏览上下文广播:concept-broadcastchannel-closed-4>已关闭标志</a> 为 false 的
  <code id=向其他浏览上下文广播:broadcastchannel-13><a href=#broadcastchannel>BroadcastChannel</a></code> 对象还有事件处理器注册在 <code id=向其他浏览上下文广播:event-message-2><a href=indices.html#event-message>message</a></code>
  事件上时，<code id=向其他浏览上下文广播:broadcastchannel-14><a href=#broadcastchannel>BroadcastChannel</a></code> 对象的
  <a href=#broadcastchannel-settings-object id=向其他浏览上下文广播:broadcastchannel-settings-object-8><code>BroadcastChannel</code> 设置对象</a>
  指定的 <a href=webappapis.html#concept-settings-object-global id=向其他浏览上下文广播:concept-settings-object-global-3>全局对象</a> 上必须有一个强引用指向
  <code id=向其他浏览上下文广播:broadcastchannel-15><a href=#broadcastchannel>BroadcastChannel</a></code> 对象自己。</p>

  <p><dfn id=dom-broadcastchannel-close><code>close()</code></dfn> 方法必须
  把调用它的 <code id=向其他浏览上下文广播:broadcastchannel-16><a href=#broadcastchannel>BroadcastChannel</a></code> 对象的
  <a href=#concept-broadcastchannel-closed id=向其他浏览上下文广播:concept-broadcastchannel-closed-5>已关闭标志</a>
  设置为 true。</p>

  <p class=note>强烈鼓励作者在不需要它们时，显式地关闭 <code id=向其他浏览上下文广播:broadcastchannel-17><a href=#broadcastchannel>BroadcastChannel</a></code> 对象，
  这样它们就可以被垃圾回收了。
  创建很多 <code id=向其他浏览上下文广播:broadcastchannel-18><a href=#broadcastchannel>BroadcastChannel</a></code> 对象并在留有一个事件监听器时抛弃但不关闭他们，
  会导致明显的内存泄露，因为只要它们有事件处理器（或页面或 Worker 别关闭），这些对象就会继续活着。</p>

  <hr>

  <p>下面的例子是所有实现 <code id=向其他浏览上下文广播:broadcastchannel-19><a href=#broadcastchannel>BroadcastChannel</a></code> 接口的对象
  必须
  以 <a href=webappapis.html#event-handler-idl-attributes id=向其他浏览上下文广播:event-handler-idl-attributes>事件处理器 IDL 属性</a> 方式支持的
  <a href=webappapis.html#event-handlers id=向其他浏览上下文广播:event-handlers>事件处理器</a>
  （以及对应的 <a href=webappapis.html#event-handler-event-type id=向其他浏览上下文广播:event-handler-event-type>事件处理器事件类型</a>）：</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=向其他浏览上下文广播:event-handlers-2>事件处理器</a> <th><a href=webappapis.html#event-handler-event-type id=向其他浏览上下文广播:event-handler-event-type-2>事件处理器事件类型</a>
   <tbody><tr><td><dfn id=handler-broadcastchannel-onmessage><code>onmessage</code></dfn> <div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/onmessage title="The BroadcastChannel.onmessage event handler is a property that specifies the function to execute when a message event, of type MessageEvent, is received by this BroadcastChannel. Such an event is sent by the browser with a message broadcasted to the channel.">BroadcastChannel/onmessage</a><div class=support><span class="firefox yes"><span>Firefox</span><span>38+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera yes"><span>Opera</span><span>41+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>38+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>54+</span></span><span class="webview_android yes"><span>WebView Android</span><span>54+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>6.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>41+</span></span></div></div></div><td> <code id=向其他浏览上下文广播:event-message-3><a href=indices.html#event-message>message</a></code>
    <tr><td><dfn id=handler-broadcastchannel-onmessageerror><code>onmessageerror</code></dfn> <div class="mdn-anno wrapped before"><button onclick=toggleStatus(this) class=mdn-anno-btn><span>MDN</span></button><div class=feature><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel/onmessageerror title="The onmessageerror event handler of the BroadcastChannel interface is an EventListener, called whenever an MessageEvent of type messageerror is fired on the BroadcastChannel instance — that is, when it receives a message that cannot be deserialized.">BroadcastChannel/onmessageerror</a><div class=support><span class="firefox yes"><span>Firefox</span><span>57+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>60+</span></span><hr><span class="opera yes"><span>Opera</span><span>47+</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge no"><span>Edge (Legacy)</span><span>No</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android yes"><span>Firefox Android</span><span>57+</span></span><span class="safari_ios no"><span>Safari iOS</span><span>No</span></span><span class="chrome_android yes"><span>Chrome Android</span><span>60+</span></span><span class="webview_android yes"><span>WebView Android</span><span>60+</span></span><span class="samsunginternet_android yes"><span>Samsung Internet</span><span>8.0+</span></span><span class="opera_android yes"><span>Opera Android</span><span>44+</span></span></div></div></div><td> <code id=向其他浏览上下文广播:event-messageerror-2><a href=indices.html#event-messageerror>messageerror</a></code>
  </table>

  

  <div class=example>

   <p>假设一个页面想要知道用户登出，包括从其他标签页登出：</p>

   <pre>var authChannel = new BroadcastChannel('auth');
authChannel.onmessage = function (event) {
  if (event.data == 'logout')
    showLogout();
}

function logoutRequested() {
  // called when the user asks us to log them out
  doLogout();
  showLogout();
  authChannel.postMessage('logout');
}

function doLogout() {
  // actually log the user out (e.g. clearing cookies)
  // ...
}

function showLogout() {
  // update the UI to indicate we're logged out
  // ...
}</pre>

  </div>






  <nav><a href=web-sockets.html>← 9.3 Web sockets</a> — <a href=./>Table of Contents</a> — <a href=workers.html>10 Web 工作线程 →</a></nav>
<script src=/html/resources/zh-cn.js></script>
