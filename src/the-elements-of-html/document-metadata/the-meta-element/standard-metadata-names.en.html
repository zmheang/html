  <h5>Standard metadata names</h5>

  <p>This specification defines a few names for the <code data-x="attr-meta-name">name</code>
  attribute of the <code>meta</code> element.</p>

  <p>Names are case-insensitive<span class=impl>, and must be compared in an <span>ASCII
  case-insensitive</span> manner</span>.</p>

  <dl>

   <dt><dfn><code data-x="meta-application-name">application-name</code></dfn></dt>

   <dd>

    <p>The value must be a short free-form string giving the name of the Web application that the
    page represents. If the page is not a Web application, the <code
    data-x="meta-application-name">application-name</code> metadata name must not be used.
    Translations of the Web application's name may be given, using the <code
    data-x="attr-lang">lang</code> attribute to specify the language of each name.</p>

    <p>There must not be more than one <code>meta</code> element with a given <span>language</span>
    and where the <code data-x="attr-meta-name">name</code> attribute value is an
    <span>ASCII case-insensitive</span> match for
    <code data-x="meta-application-name">application-name</code> per document.</p>

    <div w-nodev>

    <p>User agents may use the application name in UI in preference to the page's
    <code>title</code>, since the title might include status messages and the like relevant to the
    status of the page at a particular moment in time instead of just being the name of the
    application.</p>

    <p>To find the application name to use given an ordered list of languages (e.g. British English,
    American English, and English), user agents must run the following steps:</p>

    <ol>

     <li><p>Let <var>languages</var> be the list of languages.</p></li>

     <li><p>Let <var>default language</var> be the <span>language</span> of the
     <code>Document</code>'s <span>document element</span>, if any, and if that language is not
     unknown.</p>

     <li><p>If there is a <var>default language</var>, and if it is not the same language
     as any of the languages in <var>languages</var>, append it to <var>languages</var>.</p></li>

     <li>

      <p>Let <var>winning language</var> be the first language in <var>languages</var> for which
      there is a <code>meta</code> element in the <code>Document</code> where the
      <code data-x="attr-meta-name">name</code> attribute value is an
      <span>ASCII case-insensitive</span> match for
      <code data-x="meta-application-name">application-name</code> and whose
      <span>language</span> is the language in question.</p>

      <p>If none of the languages have such a <code>meta</code> element, then return;
      there's no given application name.</p>

     </li>

     <li>

      <p>Return the value of the <code data-x="attr-meta-content">content</code> attribute of the
      first <code>meta</code> element in the <code>Document</code> in <span>tree order</span> where the
      <code data-x="attr-meta-name">name</code> attribute value is an
      <span>ASCII case-insensitive</span> match for <code data-x="meta-application-name">application-name</code>
      and whose <span>language</span> is <var>winning language</var>.</p>

     </li>

    </ol>

    <p class="note">This algorithm would be used by a browser when it needs a name for the page, for
    instance, to label a bookmark. The languages it would provide to the algorithm would be the
    user's preferred languages.</p>

    </div>

   </dd>

   <dt><dfn><code data-x="meta-author">author</code></dfn></dt>

   <dd><p>The value must be a free-form string giving the name of one of the page's
   authors.</p></dd>

   <dt><dfn><code data-x="meta-description">description</code></dfn></dt>

   <dd><p>The value must be a free-form string that describes the page. The value must be
   appropriate for use in a directory of pages, e.g. in a search engine. There must not be more than
   one <code>meta</code> element where the <code data-x="attr-meta-name">name</code> attribute value
   is an <span>ASCII case-insensitive</span> match for
   <code data-x="meta-description">description</code> per document.</p></dd>

   <dt><dfn><code data-x="meta-generator">generator</code></dfn></dt>

   <dd>

    <p>The value must be a free-form string that identifies one of the software packages used to
    generate the document. This value must not be used on pages whose markup is not generated by
    software, e.g. pages whose markup was written by a user in a text editor.</p>

    <div class="example">

     <p>Here is what a tool called "Frontweaver" could include in its output, in the page's
     <code>head</code> element, to identify itself as the tool used to generate the page:</p>

     <pre><code class="html" data-x="">&lt;meta name=generator content="Frontweaver 8.2"></code></pre>

    </div>

   </dd>

   <dt><dfn><code data-x="meta-keywords">keywords</code></dfn></dt>

   <dd>

    <p>The value must be a <span>set of comma-separated tokens</span>, each of which is a keyword
    relevant to the page.</p>

    <div class="example">

     <p>This page about typefaces on British motorways uses a <code>meta</code> element to specify
     some keywords that users might use to look for the page:</p>

     <pre><code class="html" data-x="">&lt;!DOCTYPE HTML>
&lt;html lang="en-GB">
 &lt;head>
  &lt;title>Typefaces on UK motorways&lt;/title>
  &lt;meta name="keywords" content="british,type face,font,fonts,highway,highways">
 &lt;/head>
 &lt;body>
  ...</code></pre>

    </div>

    <p class="note">Many search engines do not consider such keywords, because this feature has
    historically been used unreliably and even misleadingly as a way to spam search engine results
    in a way that is not helpful for users.</p>

    <div w-nodev>

    <p>To obtain the list of keywords that the author has specified as applicable to the page, the
    user agent must run the following steps:</p>

    <ol>

     <li><p>Let <var>keywords</var> be an empty list.</p></li>

     <li>

      <p>For each <code>meta</code> element with a <code data-x="attr-meta-name">name</code>
      attribute and a <code data-x="attr-meta-content">content</code> attribute and where the <code
      data-x="attr-meta-name">name</code> attribute value is an <span>ASCII case-insensitive</span>
      match for <code data-x="meta-keywords">keywords</code>:</p>

      <ol>

       <li><p><span data-x="split a string on commas">Split the value of the element's <code
       data-x="attr-meta-content">content</code> attribute on commas</span>.</p></li>

       <li><p>Add the resulting tokens, if any, to <var>keywords</var>.</p></li>

      </ol>

     </li>

     <li><p>Remove any duplicates from <var>keywords</var>.</p></li>

     <li><p>Return <var>keywords</var>. This is the list of keywords that the author has
     specified as applicable to the page.</p></li>

    </ol>

    <p>User agents should not use this information when there is insufficient confidence in the
    reliability of the value.</p>

    <p class="example">For instance, it would be reasonable for a content management system to use
    the keyword information of pages within the system to populate the index of a site-specific
    search engine, but a large-scale content aggregator that used this information would likely find
    that certain users would try to game its ranking mechanism through the use of inappropriate
    keywords.</p>

    </div>

   </dd>

   <dt><dfn><code data-x="meta-referrer">referrer</code></dfn></dt>

   <dd>
    <p>The value must be a <span>referrer policy</span>, which defines the default <span>referrer
    policy</span> for the <code>Document</code>. <ref spec="REFERRERPOLICY"></p>

    <div w-nodev>

    <p>If any <code>meta</code> elements are <span data-x="node is inserted into a
    document">inserted into the document</span> or <span data-x="node is removed from a
    document">removed from the document</span>, or existing
    <code>meta</code> elements have their <code data-x="attr-meta-name">name</code> or <code
    data-x="attr-meta-content">content</code> attributes changed, user agents must run the
    following algorithm:</p>

    <ol>
     <li>
      <p>Let <var>candidate elements</var> be the list of all <code>meta</code> elements that
      meet the following criteria, in <span>tree order</span>:</p>

      <ul class="brief">
       <li>The element is <span>in a document tree</span></li>
       <li>The element has a <code data-x="attr-meta-name">name</code> attribute, whose value is
       an <span>ASCII case-insensitive</span> match for <code data-x="meta-referrer">referrer</code></li>
       <li>The element has a <code data-x="attr-meta-content">content</code> attribute, whose value
       is not the empty string</li>
       <li>The element is a child of <span>the <code>head</code> element</span> of the document</li>
      </ul>
     </li>

     <li>
      <p>For each <var>element</var> in <var>candidate elements</var>:</p>

      <ol>
       <li><p>Let <var>value</var> be the value of <var>element</var>'s <code
       data-x="attr-meta-content">content</code> attribute, <span>converted to ASCII
       lowercase</span>.</p></li>

       <li>
        <p>If <var>value</var> is one of the values given in the first column of the following
        table, then set <var>value</var> to the value given in the second column:</p>

        <table>
         <thead>
          <tr>
           <th>Legacy value
           <th>Referrer policy
         <tbody>
          <tr>
           <td><code data-x="">never</code>
           <td><code data-x="referrer-policy-no-referrer">no-referrer</code>
          <tr>
           <td><code data-x="">default</code>
           <td><code data-x="referrer-policy-no-referrer-when-downgrade">no-referrer-when-downgrade</code>
          <tr>
           <td><code data-x="">always</code>
           <td><code data-x="referrer-policy-unsafe-url">unsafe-url</code>
          <tr>
           <td><code data-x="">origin-when-crossorigin</code>
           <td><code data-x="referrer-policy-origin-when-cross-origin">origin-when-cross-origin</code>
        </table>
       </li>

       <li><p>If <var>value</var> is a <span>referrer policy</span>, then set <var>element</var>'s
       <span>node document</span>'s <span data-x="concept-document-referrer-policy">referrer
       policy</span> to <var>policy</var>.</p></li>
      </ol>

      <p class="note">The fact that these steps are applied for each element enables <a
      href="https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values">deployment of
      fallback values for older user agents</a>. <ref spec="REFERRERPOLICY"></p>
     </li>
    </ol>

    </div>
   </dd>

   <dt><dfn><code data-x="meta-theme-color">theme-color</code></dfn></dt>

   <dd>

    <p>The value must be a string that matches the CSS <span>&lt;color></span> production, defining
    a suggested color that user agents should use to customize the display of the page or of the
    surrounding user interface. For example, a browser might color the page's title bar with the
    specified value, or use it as a color highlight in a tab bar or task switcher.</p>

    <p>There must not be more than one <code>meta</code> element with its <code
    data-x="attr-meta-name">name</code> attribute value set to an
    <span>ASCII case-insensitive</span> match for <code
    data-x="meta-theme-color">theme-color</code> per document.</p>

    <div class="example">

     <p>This standard itself uses "WHATWG green" as its theme color:</p>

     <pre><code class="html" data-x="">&lt;!DOCTYPE HTML>
&lt;title>HTML Standard&lt;/title>
&lt;meta name="theme-color" content="#3c790a">
...</code></pre>

    </div>

    <div w-nodev>

     <p>To obtain a page's theme color, user agents must run the following steps:</p>

     <ol>
      <li>
       <p>Let <var>candidate elements</var> be the list of all <code>meta</code> elements that
       meet the following criteria, in <span>tree order</span>:</p>

       <ul class="brief">
        <li>The element is <span>in a document tree</span></li>
        <li>The element has a <code data-x="attr-meta-name">name</code> attribute, whose value is
        an <span>ASCII case-insensitive</span> match for <code data-x="meta-theme-color">theme-color</code></li>
        <li>The element has a <code data-x="attr-meta-content">content</code> attribute</li>
       </ul>
      </li>

      <li>
       <p>For each <var>element</var> in <var>candidate elements</var>:</p>

       <ol>
        <li><p>Let <var>value</var> be the result of <span data-x="strip leading and trailing ASCII
        whitespace">stripping leading and trailing ASCII whitespace</span> from the value of
        <var>element</var>'s <code data-x="attr-meta-content">content</code> attribute.</p></li>

        <li><p>Let <var>color</var> be the result of <span data-x="parse a CSS &lt;color>
        value">parsing</span> <var>value</var>.</p></li>

        <li><p>If <var>color</var> is not failure, then return <var>color</var>.</p></li>
       </ol>
      </li>

      <li><p>Return nothing (the page has no theme color).</p></li>
     </ol>

     <p>If any <code>meta</code> elements are <span data-x="node is inserted into a
     document">inserted into the document</span> or <span data-x="node is removed from a
     document">removed from the document</span>, or existing <code>meta</code> elements have their
     <code data-x="attr-meta-name">name</code> or <code data-x="attr-meta-content">content</code>
     attributes changed, user agents must re-run the above algorithm and apply the result to any
     affected UI.</p>

    </div>

    <p>When using the theme color in UI, user agents may adjust it in implementation-specific ways
    to make it more suitable for the UI in question. For example, if a user agent intends to use
    the theme color as a background and display white text over it, it might use a darker variant of
    the theme color in that part of the UI, to ensure adequate contrast.</p>

   </dd>

  </dl>



